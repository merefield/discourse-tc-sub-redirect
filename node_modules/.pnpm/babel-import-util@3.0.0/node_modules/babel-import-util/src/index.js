"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportUtil = void 0;
class ImportUtil {
    constructor(babel, program) {
        this.babel = babel;
        this.program = program;
        this.t = babel.types;
    }
    // remove one imported binding. If this is the last thing imported from the
    // given moduleSpecifier, the whole statement will also be removed.
    removeImport(moduleSpecifier, exportedName) {
        for (let topLevelPath of this.program.get('body')) {
            if (!matchModule(topLevelPath, moduleSpecifier)) {
                continue;
            }
            let importSpecifierPath = topLevelPath
                .get('specifiers')
                .find((specifierPath) => matchSpecifier(specifierPath, exportedName));
            if (importSpecifierPath) {
                if (topLevelPath.node.specifiers.length === 1) {
                    topLevelPath.remove();
                }
                else {
                    importSpecifierPath.remove();
                }
            }
        }
    }
    // remove all imports from the given moduleSpecifier
    removeAllImports(moduleSpecifier) {
        for (let topLevelPath of this.program.get('body')) {
            if (matchModule(topLevelPath, moduleSpecifier)) {
                topLevelPath.remove();
            }
        }
    }
    // Import the given value (if needed) and return an Identifier representing
    // it.
    //
    // This method is trickier to use safely than our higher-level methods
    // (`insertAfter`, `insertBefore`, `replaceWith`, `mutate`) because after you
    // insert the identifier into the AST, it's up to you to ensure that babel's
    // scope system is aware of the new reference. The other methods do that for
    // you automatically.
    import(
    // the spot at which you will insert the Identifier we return to you
    target, 
    // the path to the module you're importing from
    moduleSpecifier, 
    // the name you're importing from that module. Use "default" for the default
    // export. Use "*" for the namespace.
    exportedName, 
    // Optional hint for helping us pick a name for the imported binding
    nameHint) {
        return this.unreferencedImport(target, moduleSpecifier, exportedName, desiredName(nameHint, exportedName, defaultNameHint(target)));
    }
    // Import the given value (if needed) and return an Identifier representing
    // it.
    unreferencedImport(
    // the spot at which you will insert the Identifier we return to you
    target, 
    // the path to the module you're importing from
    moduleSpecifier, 
    // the name you're importing from that module. Use "default" for the default
    // export. Use "*" for the namespace.
    exportedName, 
    // the preferred name you want, if we neeed to create a new binding. You
    // might get something similar instead, to avoid collisions.
    preferredName) {
        var _a;
        let isNamespaceImport = exportedName === '*';
        let isDefaultImport = exportedName === 'default';
        let isNamedImport = !isDefaultImport && !isNamespaceImport;
        let declaration = this.findImportFrom(moduleSpecifier);
        let hasNamespaceSpecifier = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === 'ImportNamespaceSpecifier');
        let hasNamedSpecifiers = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === 'ImportSpecifier');
        /**
         * the file has a preexisting non-namespace import and a transform tries to add a namespace import, so they don't get combined
         * the file has a preexisting namespace import and a transform tries to add a non-namespace import, so they don't get combined
         * the file has a preexisting namespace import and a transform tries to add a namespace import, so they don't get combined
         */
        let cannotUseExistingDeclaration = (hasNamedSpecifiers && isNamespaceImport) ||
            (hasNamespaceSpecifier && isNamedImport) ||
            (hasNamespaceSpecifier && isNamespaceImport);
        if (!cannotUseExistingDeclaration && declaration) {
            let specifier = declaration
                .get('specifiers')
                .find((spec) => matchSpecifier(spec, exportedName));
            if (specifier && ((_a = target.scope.getBinding(specifier.node.local.name)) === null || _a === void 0 ? void 0 : _a.kind) === 'module') {
                return this.t.identifier(specifier.node.local.name);
            }
            else {
                return this.addSpecifier(target, declaration, exportedName, preferredName);
            }
        }
        else {
            let declaration = this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));
            return this.addSpecifier(target, declaration, exportedName, preferredName);
        }
    }
    importForSideEffect(moduleSpecifier) {
        let declaration = this.findImportFrom(moduleSpecifier);
        if (!declaration) {
            this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));
        }
    }
    replaceWith(target, fn) {
        return this.mutate((i) => {
            target.replaceWith(fn(i));
            // the return value of replaceWith is not a reliable way to get the
            // updated path, at least in the case where the user replaced an
            // expression with a statement. Instead we will rely on the fact that path
            // replacement also mutates its argument, so `target` now points at the
            // newly replaced path.
            return target;
        }, defaultNameHint(target));
    }
    insertAfter(target, fn) {
        return this.mutate((i) => target.insertAfter(fn(i))[0], defaultNameHint(target));
    }
    insertBefore(target, fn) {
        return this.mutate((i) => target.insertBefore(fn(i))[0], defaultNameHint(target));
    }
    // Low-level method for when you don't want to use our higher-level methods
    // (replaceWith, insertBefore, insertAfter)
    mutate(fn, defaultNameHint) {
        let symbols = new Map();
        const importer = {
            import: (moduleSpecifier, exportedName, nameHint) => {
                let identifier = this.t.identifier('__babel_import_util_placeholder__');
                symbols.set(identifier, { moduleSpecifier, exportedName, nameHint });
                return identifier;
            },
        };
        const updateReference = (path) => {
            if (!path.isIdentifier()) {
                return;
            }
            let hit = symbols.get(path.node);
            if (hit) {
                let newIdentifier = this.unreferencedImport(path, hit.moduleSpecifier, hit.exportedName, desiredName(hit.nameHint, hit.exportedName, defaultNameHint));
                path.replaceWith(newIdentifier);
                let binding = path.scope.getBinding(newIdentifier.name);
                if (!binding) {
                    // we create the binding at the point where we add the import, so this
                    // would indicate broken behavior
                    throw new Error(`bug: this is supposed to never happen`);
                }
                binding.reference(path);
            }
        };
        let result = fn(importer);
        updateReference(result);
        this.babel.traverse(result.node, {
            ReferencedIdentifier: (path) => {
                updateReference(path);
            },
        }, result.scope, {}, result);
        return result;
    }
    addSpecifier(target, declaration, exportedName, preferredName) {
        let local = this.t.identifier(unusedNameLike(target, preferredName));
        let specifier = this.buildSpecifier(exportedName, local);
        let added;
        if (specifier.type === 'ImportDefaultSpecifier') {
            declaration.node.specifiers.unshift(specifier);
            added = declaration.get(`specifiers.0`);
        }
        else {
            declaration.node.specifiers.push(specifier);
            added = declaration.get(`specifiers.${declaration.node.specifiers.length - 1}`);
        }
        declaration.scope.registerBinding('module', added);
        return local;
    }
    buildSpecifier(exportedName, localName) {
        switch (exportedName) {
            case 'default':
                return this.t.importDefaultSpecifier(localName);
            case '*':
                return this.t.importNamespaceSpecifier(localName);
            default:
                return this.t.importSpecifier(localName, this.t.identifier(exportedName));
        }
    }
    findImportFrom(moduleSpecifier) {
        for (let path of this.program.get('body')) {
            if (path.isImportDeclaration() &&
                path.node.source.value === moduleSpecifier &&
                path.node.importKind !== 'type') {
                return path;
            }
        }
        return undefined;
    }
    insertAfterExistingImports(statement) {
        let lastIndex;
        for (let [index, node] of this.program.node.body.entries()) {
            if (node.type === 'ImportDeclaration') {
                lastIndex = index;
            }
        }
        if (lastIndex == null) {
            // we are intentionally not using babel's container-aware methods, because
            // while in theory it's nice that they schedule other plugins to run on
            // our nodes, in practice those nodes might get mutated or removed by some
            // other plugin in the intervening time causing failures.
            this.program.node.body.unshift(statement);
            return this.program.get('body.0');
        }
        else {
            this.program.node.body.splice(lastIndex + 1, 0, statement);
            return this.program.get(`body.${lastIndex + 1}`);
        }
    }
}
exports.ImportUtil = ImportUtil;
function unusedNameLike(path, name) {
    let candidate = name;
    let counter = 0;
    while (path.scope.hasBinding(candidate)) {
        candidate = `${name}${counter++}`;
    }
    return candidate;
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
function desiredName(nameHint, exportedName, defaultNameHint) {
    if (nameHint) {
        // first we opportunistically do camelization when an illegal character is
        // followed by a lowercase letter, in an effort to aid readability of the
        // output.
        let cleaned = nameHint.replace(/[^a-zA-Z_]([a-z])/g, (_m, letter) => letter.toUpperCase());
        // then we unliterally strip all remaining illegal characters.
        cleaned = cleaned.replace(/[^a-zA-Z_]/g, '');
        return cleaned;
    }
    if (exportedName === 'default' || exportedName === '*') {
        return defaultNameHint !== null && defaultNameHint !== void 0 ? defaultNameHint : 'a';
    }
    else {
        return exportedName;
    }
}
function defaultNameHint(target) {
    if (target === null || target === void 0 ? void 0 : target.isIdentifier()) {
        return target.node.name;
    }
    else if (target) {
        return target.scope.generateUidIdentifierBasedOnNode(target.node).name;
    }
    else {
        return undefined;
    }
}
function matchSpecifier(spec, exportedName) {
    switch (exportedName) {
        case 'default':
            return spec.isImportDefaultSpecifier();
        case '*':
            return spec.isImportNamespaceSpecifier();
        default:
            return spec.isImportSpecifier() && name(spec.node.imported) === exportedName;
    }
}
function matchModule(path, moduleSpecifier) {
    return path.isImportDeclaration() && path.get('source').node.value === moduleSpecifier;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQSxNQUFhLFVBQVU7SUFHckIsWUFBb0IsS0FBbUIsRUFBVSxPQUE0QjtRQUF6RCxVQUFLLEdBQUwsS0FBSyxDQUFjO1FBQVUsWUFBTyxHQUFQLE9BQU8sQ0FBcUI7UUFDM0UsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCwyRUFBMkU7SUFDM0UsbUVBQW1FO0lBQ25FLFlBQVksQ0FBQyxlQUF1QixFQUFFLFlBQW9CO1FBQ3hELEtBQUssSUFBSSxZQUFZLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDakQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsZUFBZSxDQUFDLEVBQUU7Z0JBQy9DLFNBQVM7YUFDVjtZQUVELElBQUksbUJBQW1CLEdBQUcsWUFBWTtpQkFDbkMsR0FBRyxDQUFDLFlBQVksQ0FBQztpQkFDakIsSUFBSSxDQUFDLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxjQUFjLENBQUMsYUFBYSxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDeEUsSUFBSSxtQkFBbUIsRUFBRTtnQkFDdkIsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO29CQUM3QyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUM7aUJBQ3ZCO3FCQUFNO29CQUNMLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxDQUFDO2lCQUM5QjthQUNGO1NBQ0Y7SUFDSCxDQUFDO0lBRUQsb0RBQW9EO0lBQ3BELGdCQUFnQixDQUFDLGVBQXVCO1FBQ3RDLEtBQUssSUFBSSxZQUFZLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDakQsSUFBSSxXQUFXLENBQUMs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SUFBSSxDQUFDO0tBQ3hFO1NBQU07UUFDTCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxJQUFtQixFQUFFLFlBQW9CO0lBQy9ELFFBQVEsWUFBWSxFQUFFO1FBQ3BCLEtBQUssU0FBUztZQUNaLE9BQU8sSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUM7UUFDekMsS0FBSyxHQUFHO1lBQ04sT0FBTyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztRQUMzQztZQUNFLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssWUFBWSxDQUFDO0tBQ2hGO0FBQ0gsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUNsQixJQUFtQixFQUNuQixlQUF1QjtJQUV2QixPQUFPLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxlQUFlLENBQUM7QUFDekYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlICogYXMgQmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyB0eXBlcyBhcyB0LCBOb2RlUGF0aCB9IGZyb20gJ0BiYWJlbC9jb3JlJztcblxuZXhwb3J0IGNsYXNzIEltcG9ydFV0aWwge1xuICBwcml2YXRlIHQ6IHR5cGVvZiBCYWJlbC50eXBlcztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGJhYmVsOiB0eXBlb2YgQmFiZWwsIHByaXZhdGUgcHJvZ3JhbTogTm9kZVBhdGg8dC5Qcm9ncmFtPikge1xuICAgIHRoaXMudCA9IGJhYmVsLnR5cGVzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIG9uZSBpbXBvcnRlZCBiaW5kaW5nLiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRoaW5nIGltcG9ydGVkIGZyb20gdGhlXG4gIC8vIGdpdmVuIG1vZHVsZVNwZWNpZmllciwgdGhlIHdob2xlIHN0YXRlbWVudCB3aWxsIGFsc28gYmUgcmVtb3ZlZC5cbiAgcmVtb3ZlSW1wb3J0KG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLCBleHBvcnRlZE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGZvciAobGV0IHRvcExldmVsUGF0aCBvZiB0aGlzLnByb2dyYW0uZ2V0KCdib2R5JykpIHtcbiAgICAgIGlmICghbWF0Y2hNb2R1bGUodG9wTGV2ZWxQYXRoLCBtb2R1bGVTcGVjaWZpZXIpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgaW1wb3J0U3BlY2lmaWVyUGF0aCA9IHRvcExldmVsUGF0aFxuICAgICAgICAuZ2V0KCdzcGVjaWZpZXJzJylcbiAgICAgICAgLmZpbmQoKHNwZWNpZmllclBhdGgpID0+IG1hdGNoU3BlY2lmaWVyKHNwZWNpZmllclBhdGgsIGV4cG9ydGVkTmFtZSkpO1xuICAgICAgaWYgKGltcG9ydFNwZWNpZmllclBhdGgpIHtcbiAgICAgICAgaWYgKHRvcExldmVsUGF0aC5ub2RlLnNwZWNpZmllcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdG9wTGV2ZWxQYXRoLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltcG9ydFNwZWNpZmllclBhdGgucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgYWxsIGltcG9ydHMgZnJvbSB0aGUgZ2l2ZW4gbW9kdWxlU3BlY2lmaWVyXG4gIHJlbW92ZUFsbEltcG9ydHMobW9kdWxlU3BlY2lmaWVyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBmb3IgKGxldCB0b3BMZXZlbFBhdGggb2YgdGhpcy5wcm9ncmFtLmdldCgnYm9keScpKSB7XG4gICAgICBpZiAobWF0Y2hNb2R1bGUodG9wTGV2ZWxQYXRoLCBtb2R1bGVTcGVjaWZpZXIpKSB7XG4gICAgICAgIHRvcExldmVsUGF0aC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJbXBvcnQgdGhlIGdpdmVuIHZhbHVlIChpZiBuZWVkZWQpIGFuZCByZXR1cm4gYW4gSWRlbnRpZmllciByZXByZXNlbnRpbmdcbiAgLy8gaXQuXG4gIC8vXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHRyaWNraWVyIHRvIHVzZSBzYWZlbHkgdGhhbiBvdXIgaGlnaGVyLWxldmVsIG1ldGhvZHNcbiAgLy8gKGBpbnNlcnRBZnRlcmAsIGBpbnNlcnRCZWZvcmVgLCBgcmVwbGFjZVdpdGhgLCBgbXV0YXRlYCkgYmVjYXVzZSBhZnRlciB5b3VcbiAgLy8gaW5zZXJ0IHRoZSBpZGVudGlmaWVyIGludG8gdGhlIEFTVCwgaXQncyB1cCB0byB5b3UgdG8gZW5zdXJlIHRoYXQgYmFiZWwnc1xuICAvLyBzY29wZSBzeXN0ZW0gaXMgYXdhcmUgb2YgdGhlIG5ldyByZWZlcmVuY2UuIFRoZSBvdGhlciBtZXRob2RzIGRvIHRoYXQgZm9yXG4gIC8vIHlvdSBhdXRvbWF0aWNhbGx5LlxuICBpbXBvcnQoXG4gICAgLy8gdGhlIHNwb3QgYXQgd2hpY2ggeW91IHdpbGwgaW5zZXJ0IHRoZSBJZGVudGlmaWVyIHdlIHJldHVybiB0byB5b3VcbiAgICB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4sXG5cbiAgICAvLyB0aGUgcGF0aCB0byB0aGUgbW9kdWxlIHlvdSdyZSBpbXBvcnRpbmcgZnJvbVxuICAgIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLFxuXG4gICAgLy8gdGhlIG5hbWUgeW91J3JlIGltcG9ydGluZyBmcm9tIHRoYXQgbW9kdWxlLiBVc2UgXCJkZWZhdWx0XCIgZm9yIHRoZSBkZWZhdWx0XG4gICAgLy8gZXhwb3J0LiBVc2UgXCIqXCIgZm9yIHRoZSBuYW1lc3BhY2UuXG4gICAgZXhwb3J0ZWROYW1lOiBzdHJpbmcsXG5cbiAgICAvLyBPcHRpb25hbCBoaW50IGZvciBoZWxwaW5nIHVzIHBpY2sgYSBuYW1lIGZvciB0aGUgaW1wb3J0ZWQgYmluZGluZ1xuICAgIG5hbWVIaW50Pzogc3RyaW5nXG4gICk6IHQuSWRlbnRpZmllciB7XG4gICAgcmV0dXJuIHRoaXMudW5yZWZlcmVuY2VkSW1wb3J0KFxuICAgICAgdGFyZ2V0LFxuICAgICAgbW9kdWxlU3BlY2lmaWVyLFxuICAgICAgZXhwb3J0ZWROYW1lLFxuICAgICAgZGVzaXJlZE5hbWUobmFtZUhpbnQsIGV4cG9ydGVkTmFtZSwgZGVmYXVsdE5hbWVIaW50KHRhcmdldCkpXG4gICAgKTtcbiAgfVxuXG4gIC8vIEltcG9ydCB0aGUgZ2l2ZW4gdmFsdWUgKGlmIG5lZWRlZCkgYW5kIHJldHVybiBhbiBJZGVudGlmaWVyIHJlcHJlc2VudGluZ1xuICAvLyBpdC5cbiAgcHJpdmF0ZSB1bnJlZmVyZW5jZWRJbXBvcnQoXG4gICAgLy8gdGhlIHNwb3QgYXQgd2hpY2ggeW91IHdpbGwgaW5zZXJ0IHRoZSBJZGVudGlmaWVyIHdlIHJldHVybiB0byB5b3VcbiAgICB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4sXG5cbiAgICAvLyB0aGUgcGF0aCB0byB0aGUgbW9kdWxlIHlvdSdyZSBpbXBvcnRpbmcgZnJvbVxuICAgIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLFxuXG4gICAgLy8gdGhlIG5hbWUgeW91J3JlIGltcG9ydGluZyBmcm9tIHRoYXQgbW9kdWxlLiBVc2UgXCJkZWZhdWx0XCIgZm9yIHRoZSBkZWZhdWx0XG4gICAgLy8gZXhwb3J0LiBVc2UgXCIqXCIgZm9yIHRoZSBuYW1lc3BhY2UuXG4gICAgZXhwb3J0ZWROYW1lOiBzdHJpbmcsXG5cbiAgICAvLyB0aGUgcHJlZmVycmVkIG5hbWUgeW91IHdhbnQsIGlmIHdlIG5lZWVkIHRvIGNyZWF0ZSBhIG5ldyBiaW5kaW5nLiBZb3VcbiAgICAvLyBtaWdodCBnZXQgc29tZXRoaW5nIHNpbWlsYXIgaW5zdGVhZCwgdG8gYXZvaWQgY29sbGlzaW9ucy5cbiAgICBwcmVmZXJyZWROYW1lOiBzdHJpbmdcbiAgKTogdC5JZGVudGlmaWVyIHtcbiAgICBsZXQgaXNOYW1lc3BhY2VJbXBvcnQgPSBleHBvcnRlZE5hbWUgPT09ICcqJztcbiAgICBsZXQgaXNEZWZhdWx0SW1wb3J0ID0gZXhwb3J0ZWROYW1lID09PSAnZGVmYXVsdCc7XG4gICAgbGV0IGlzTmFtZWRJbXBvcnQgPSAhaXNEZWZhdWx0SW1wb3J0ICYmICFpc05hbWVzcGFjZUltcG9ydDtcbiAgICBsZXQgZGVjbGFyYXRpb24gPSB0aGlzLmZpbmRJbXBvcnRGcm9tKG1vZHVsZVNwZWNpZmllcik7XG4gICAgbGV0IGhhc05hbWVzcGFjZVNwZWNpZmllciA9IGRlY2xhcmF0aW9uPy5ub2RlLnNwZWNpZmllcnMuZmluZChcbiAgICAgIChzKSA9PiBzLnR5cGUgPT09ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInXG4gICAgKTtcbiAgICBsZXQgaGFzTmFtZWRTcGVjaWZpZXJzID0gZGVjbGFyYXRpb24/Lm5vZGUuc3BlY2lmaWVycy5maW5kKChzKSA9PiBzLnR5cGUgPT09ICdJbXBvcnRTcGVjaWZpZXInKTtcblxuICAgIC8qKlxuICAgICAqIHRoZSBmaWxlIGhhcyBhIHByZWV4aXN0aW5nIG5vbi1uYW1lc3BhY2UgaW1wb3J0IGFuZCBhIHRyYW5zZm9ybSB0cmllcyB0byBhZGQgYSBuYW1lc3BhY2UgaW1wb3J0LCBzbyB0aGV5IGRvbid0IGdldCBjb21iaW5lZFxuICAgICAqIHRoZSBmaWxlIGhhcyBhIHByZWV4aXN0aW5nIG5hbWVzcGFjZSBpbXBvcnQgYW5kIGEgdHJhbnNmb3JtIHRyaWVzIHRvIGFkZCBhIG5vbi1uYW1lc3BhY2UgaW1wb3J0LCBzbyB0aGV5IGRvbid0IGdldCBjb21iaW5lZFxuICAgICAqIHRoZSBmaWxlIGhhcyBhIHByZWV4aXN0aW5nIG5hbWVzcGFjZSBpbXBvcnQgYW5kIGEgdHJhbnNmb3JtIHRyaWVzIHRvIGFkZCBhIG5hbWVzcGFjZSBpbXBvcnQsIHNvIHRoZXkgZG9uJ3QgZ2V0IGNvbWJpbmVkXG4gICAgICovXG4gICAgbGV0IGNhbm5vdFVzZUV4aXN0aW5nRGVjbGFyYXRpb24gPVxuICAgICAgKGhhc05hbWVkU3BlY2lmaWVycyAmJiBpc05hbWVzcGFjZUltcG9ydCkgfHxcbiAgICAgIChoYXNOYW1lc3BhY2VTcGVjaWZpZXIgJiYgaXNOYW1lZEltcG9ydCkgfHxcbiAgICAgIChoYXNOYW1lc3BhY2VTcGVjaWZpZXIgJiYgaXNOYW1lc3BhY2VJbXBvcnQpO1xuXG4gICAgaWYgKCFjYW5ub3RVc2VFeGlzdGluZ0RlY2xhcmF0aW9uICYmIGRlY2xhcmF0aW9uKSB7XG4gICAgICBsZXQgc3BlY2lmaWVyID0gZGVjbGFyYXRpb25cbiAgICAgICAgLmdldCgnc3BlY2lmaWVycycpXG4gICAgICAgIC5maW5kKChzcGVjKSA9PiBtYXRjaFNwZWNpZmllcihzcGVjLCBleHBvcnRlZE5hbWUpKTtcbiAgICAgIGlmIChzcGVjaWZpZXIgJiYgdGFyZ2V0LnNjb3BlLmdldEJpbmRpbmcoc3BlY2lmaWVyLm5vZGUubG9jYWwubmFtZSk/LmtpbmQgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnQuaWRlbnRpZmllcihzcGVjaWZpZXIubm9kZS5sb2NhbC5uYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNwZWNpZmllcih0YXJnZXQsIGRlY2xhcmF0aW9uLCBleHBvcnRlZE5hbWUsIHByZWZlcnJlZE5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVjbGFyYXRpb24gPSB0aGlzLmluc2VydEFmdGVyRXhpc3RpbmdJbXBvcnRzKFxuICAgICAgICB0aGlzLnQuaW1wb3J0RGVjbGFyYXRpb24oW10sIHRoaXMudC5zdHJpbmdMaXRlcmFsKG1vZHVsZVNwZWNpZmllcikpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkU3BlY2lmaWVyKHRhcmdldCwgZGVjbGFyYXRpb24sIGV4cG9ydGVkTmFtZSwgcHJlZmVycmVkTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgaW1wb3J0Rm9yU2lkZUVmZmVjdChtb2R1bGVTcGVjaWZpZXI6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBkZWNsYXJhdGlvbiA9IHRoaXMuZmluZEltcG9ydEZyb20obW9kdWxlU3BlY2lmaWVyKTtcbiAgICBpZiAoIWRlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzLmluc2VydEFmdGVyRXhpc3RpbmdJbXBvcnRzKFxuICAgICAgICB0aGlzLnQuaW1wb3J0RGVjbGFyYXRpb24oW10sIHRoaXMudC5zdHJpbmdMaXRlcmFsKG1vZHVsZVNwZWNpZmllcikpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlcGxhY2VXaXRoPFQgZXh0ZW5kcyB0Lk5vZGUsIFIgZXh0ZW5kcyB0Lk5vZGU+KFxuICAgIHRhcmdldDogTm9kZVBhdGg8VD4sXG4gICAgZm46IChpOiBJbXBvcnRlcikgPT4gUlxuICApOiBOb2RlUGF0aDxSPiB7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRlKChpKSA9PiB7XG4gICAgICB0YXJnZXQucmVwbGFjZVdpdGgoZm4oaSkpO1xuICAgICAgLy8gdGhlIHJldHVybiB2YWx1ZSBvZiByZXBsYWNlV2l0aCBpcyBub3QgYSByZWxpYWJsZSB3YXkgdG8gZ2V0IHRoZVxuICAgICAgLy8gdXBkYXRlZCBwYXRoLCBhdCBsZWFzdCBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgdXNlciByZXBsYWNlZCBhblxuICAgICAgLy8gZXhwcmVzc2lvbiB3aXRoIGEgc3RhdGVtZW50LiBJbnN0ZWFkIHdlIHdpbGwgcmVseSBvbiB0aGUgZmFjdCB0aGF0IHBhdGhcbiAgICAgIC8vIHJlcGxhY2VtZW50IGFsc28gbXV0YXRlcyBpdHMgYXJndW1lbnQsIHNvIGB0YXJnZXRgIG5vdyBwb2ludHMgYXQgdGhlXG4gICAgICAvLyBuZXdseSByZXBsYWNlZCBwYXRoLlxuICAgICAgcmV0dXJuIHRhcmdldCBhcyB1bmtub3duIGFzIE5vZGVQYXRoPFI+O1xuICAgIH0sIGRlZmF1bHROYW1lSGludCh0YXJnZXQpKTtcbiAgfVxuXG4gIGluc2VydEFmdGVyPFQgZXh0ZW5kcyB0Lk5vZGUsIFIgZXh0ZW5kcyB0Lk5vZGU+KFxuICAgIHRhcmdldDogTm9kZVBhdGg8VD4sXG4gICAgZm46IChpOiBJbXBvcnRlcikgPT4gUlxuICApOiBOb2RlUGF0aDxSPiB7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRlKChpKSA9PiB0YXJnZXQuaW5zZXJ0QWZ0ZXIoZm4oaSkpWzBdIGFzIE5vZGVQYXRoPFI+LCBkZWZhdWx0TmFtZUhpbnQodGFyZ2V0KSk7XG4gIH1cblxuICBpbnNlcnRCZWZvcmU8VCBleHRlbmRzIHQuTm9kZSwgUiBleHRlbmRzIHQuTm9kZT4oXG4gICAgdGFyZ2V0OiBOb2RlUGF0aDxUPixcbiAgICBmbjogKGk6IEltcG9ydGVyKSA9PiBSXG4gICk6IE5vZGVQYXRoPFI+IHtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGUoXG4gICAgICAoaSkgPT4gdGFyZ2V0Lmluc2VydEJlZm9yZShmbihpKSlbMF0gYXMgTm9kZVBhdGg8Uj4sXG4gICAgICBkZWZhdWx0TmFtZUhpbnQodGFyZ2V0KVxuICAgICk7XG4gIH1cblxuICAvLyBMb3ctbGV2ZWwgbWV0aG9kIGZvciB3aGVuIHlvdSBkb24ndCB3YW50IHRvIHVzZSBvdXIgaGlnaGVyLWxldmVsIG1ldGhvZHNcbiAgLy8gKHJlcGxhY2VXaXRoLCBpbnNlcnRCZWZvcmUsIGluc2VydEFmdGVyKVxuICBtdXRhdGU8UmVwbGFjZW1lbnQgZXh0ZW5kcyB0Lk5vZGU+KFxuICAgIGZuOiAoaW1wb3J0ZXI6IEltcG9ydGVyKSA9PiBOb2RlUGF0aDxSZXBsYWNlbWVudD4sXG4gICAgZGVmYXVsdE5hbWVIaW50Pzogc3RyaW5nXG4gICk6IE5vZGVQYXRoPFJlcGxhY2VtZW50PiB7XG4gICAgbGV0IHN5bWJvbHM6IE1hcDxcbiAgICAgIHQuSWRlbnRpZmllcixcbiAgICAgIHsgbW9kdWxlU3BlY2lmaWVyOiBzdHJpbmc7IGV4cG9ydGVkTmFtZTogc3RyaW5nOyBuYW1lSGludDogc3RyaW5nIHwgdW5kZWZpbmVkIH1cbiAgICA+ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGltcG9ydGVyOiBJbXBvcnRlciA9IHtcbiAgICAgIGltcG9ydDogKG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLCBleHBvcnRlZE5hbWU6IHN0cmluZywgbmFtZUhpbnQ/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IGlkZW50aWZpZXIgPSB0aGlzLnQuaWRlbnRpZmllcignX19iYWJlbF9pbXBvcnRfdXRpbF9wbGFjZWhvbGRlcl9fJyk7XG4gICAgICAgIHN5bWJvbHMuc2V0KGlkZW50aWZpZXIsIHsgbW9kdWxlU3BlY2lmaWVyLCBleHBvcnRlZE5hbWUsIG5hbWVIaW50IH0pO1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZVJlZmVyZW5jZSA9IChwYXRoOiBOb2RlUGF0aCkgPT4ge1xuICAgICAgaWYgKCFwYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBoaXQgPSBzeW1ib2xzLmdldChwYXRoLm5vZGUpO1xuICAgICAgaWYgKGhpdCkge1xuICAgICAgICBsZXQgbmV3SWRlbnRpZmllciA9IHRoaXMudW5yZWZlcmVuY2VkSW1wb3J0KFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgaGl0Lm1vZHVsZVNwZWNpZmllcixcbiAgICAgICAgICBoaXQuZXhwb3J0ZWROYW1lLFxuICAgICAgICAgIGRlc2lyZWROYW1lKGhpdC5uYW1lSGludCwgaGl0LmV4cG9ydGVkTmFtZSwgZGVmYXVsdE5hbWVIaW50KVxuICAgICAgICApO1xuICAgICAgICBwYXRoLnJlcGxhY2VXaXRoKG5ld0lkZW50aWZpZXIpO1xuICAgICAgICBsZXQgYmluZGluZyA9IHBhdGguc2NvcGUuZ2V0QmluZGluZyhuZXdJZGVudGlmaWVyLm5hbWUpO1xuICAgICAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgICAgICAvLyB3ZSBjcmVhdGUgdGhlIGJpbmRpbmcgYXQgdGhlIHBvaW50IHdoZXJlIHdlIGFkZCB0aGUgaW1wb3J0LCBzbyB0aGlzXG4gICAgICAgICAgLy8gd291bGQgaW5kaWNhdGUgYnJva2VuIGJlaGF2aW9yXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBidWc6IHRoaXMgaXMgc3VwcG9zZWQgdG8gbmV2ZXIgaGFwcGVuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZy5yZWZlcmVuY2UocGF0aCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCByZXN1bHQgPSBmbihpbXBvcnRlcik7XG4gICAgdXBkYXRlUmVmZXJlbmNlKHJlc3VsdCk7XG4gICAgdGhpcy5iYWJlbC50cmF2ZXJzZShcbiAgICAgIHJlc3VsdC5ub2RlLFxuICAgICAge1xuICAgICAgICBSZWZlcmVuY2VkSWRlbnRpZmllcjogKHBhdGgpID0+IHtcbiAgICAgICAgICB1cGRhdGVSZWZlcmVuY2UocGF0aCk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcmVzdWx0LnNjb3BlLFxuICAgICAge30sXG4gICAgICByZXN1bHRcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGFkZFNwZWNpZmllcihcbiAgICB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4sXG4gICAgZGVjbGFyYXRpb246IE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+LFxuICAgIGV4cG9ydGVkTmFtZTogc3RyaW5nLFxuICAgIHByZWZlcnJlZE5hbWU6IHN0cmluZ1xuICApOiB0LklkZW50aWZpZXIge1xuICAgIGxldCBsb2NhbCA9IHRoaXMudC5pZGVudGlmaWVyKHVudXNlZE5hbWVMaWtlKHRhcmdldCwgcHJlZmVycmVkTmFtZSkpO1xuICAgIGxldCBzcGVjaWZpZXIgPSB0aGlzLmJ1aWxkU3BlY2lmaWVyKGV4cG9ydGVkTmFtZSwgbG9jYWwpO1xuICAgIGxldCBhZGRlZDogTm9kZVBhdGg7XG4gICAgaWYgKHNwZWNpZmllci50eXBlID09PSAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicpIHtcbiAgICAgIGRlY2xhcmF0aW9uLm5vZGUuc3BlY2lmaWVycy51bnNoaWZ0KHNwZWNpZmllcik7XG4gICAgICBhZGRlZCA9IGRlY2xhcmF0aW9uLmdldChgc3BlY2lmaWVycy4wYCkgYXMgTm9kZVBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2xhcmF0aW9uLm5vZGUuc3BlY2lmaWVycy5wdXNoKHNwZWNpZmllcik7XG4gICAgICBhZGRlZCA9IGRlY2xhcmF0aW9uLmdldChgc3BlY2lmaWVycy4ke2RlY2xhcmF0aW9uLm5vZGUuc3BlY2lmaWVycy5sZW5ndGggLSAxfWApIGFzIE5vZGVQYXRoO1xuICAgIH1cbiAgICBkZWNsYXJhdGlvbi5zY29wZS5yZWdpc3RlckJpbmRpbmcoJ21vZHVsZScsIGFkZGVkKTtcbiAgICByZXR1cm4gbG9jYWw7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkU3BlY2lmaWVyKGV4cG9ydGVkTmFtZTogc3RyaW5nLCBsb2NhbE5hbWU6IHQuSWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAoZXhwb3J0ZWROYW1lKSB7XG4gICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudC5pbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsTmFtZSk7XG4gICAgICBjYXNlICcqJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudC5pbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWxOYW1lKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnQuaW1wb3J0U3BlY2lmaWVyKGxvY2FsTmFtZSwgdGhpcy50LmlkZW50aWZpZXIoZXhwb3J0ZWROYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaW5kSW1wb3J0RnJvbShtb2R1bGVTcGVjaWZpZXI6IHN0cmluZyk6IE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+IHwgdW5kZWZpbmVkIHtcbiAgICBmb3IgKGxldCBwYXRoIG9mIHRoaXMucHJvZ3JhbS5nZXQoJ2JvZHknKSkge1xuICAgICAgaWYgKFxuICAgICAgICBwYXRoLmlzSW1wb3J0RGVjbGFyYXRpb24oKSAmJlxuICAgICAgICBwYXRoLm5vZGUuc291cmNlLnZhbHVlID09PSBtb2R1bGVTcGVjaWZpZXIgJiZcbiAgICAgICAgcGF0aC5ub2RlLmltcG9ydEtpbmQgIT09ICd0eXBlJ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnNlcnRBZnRlckV4aXN0aW5nSW1wb3J0czxTIGV4dGVuZHMgdC5TdGF0ZW1lbnQ+KHN0YXRlbWVudDogUyk6IE5vZGVQYXRoPFM+IHtcbiAgICBsZXQgbGFzdEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgW2luZGV4LCBub2RlXSBvZiB0aGlzLnByb2dyYW0ubm9kZS5ib2R5LmVudHJpZXMoKSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0ltcG9ydERlY2xhcmF0aW9uJykge1xuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCA9PSBudWxsKSB7XG4gICAgICAvLyB3ZSBhcmUgaW50ZW50aW9uYWxseSBub3QgdXNpbmcgYmFiZWwncyBjb250YWluZXItYXdhcmUgbWV0aG9kcywgYmVjYXVzZVxuICAgICAgLy8gd2hpbGUgaW4gdGhlb3J5IGl0J3MgbmljZSB0aGF0IHRoZXkgc2NoZWR1bGUgb3RoZXIgcGx1Z2lucyB0byBydW4gb25cbiAgICAgIC8vIG91ciBub2RlcywgaW4gcHJhY3RpY2UgdGhvc2Ugbm9kZXMgbWlnaHQgZ2V0IG11dGF0ZWQgb3IgcmVtb3ZlZCBieSBzb21lXG4gICAgICAvLyBvdGhlciBwbHVnaW4gaW4gdGhlIGludGVydmVuaW5nIHRpbWUgY2F1c2luZyBmYWlsdXJlcy5cbiAgICAgIHRoaXMucHJvZ3JhbS5ub2RlLmJvZHkudW5zaGlmdChzdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbS5nZXQoJ2JvZHkuMCcpIGFzIE5vZGVQYXRoPFM+O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb2dyYW0ubm9kZS5ib2R5LnNwbGljZShsYXN0SW5kZXggKyAxLCAwLCBzdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbS5nZXQoYGJvZHkuJHtsYXN0SW5kZXggKyAxfWApIGFzIE5vZGVQYXRoPFM+O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bnVzZWROYW1lTGlrZShwYXRoOiBOb2RlUGF0aDx0Lk5vZGU+LCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgY2FuZGlkYXRlID0gbmFtZTtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICB3aGlsZSAocGF0aC5zY29wZS5oYXNCaW5kaW5nKGNhbmRpZGF0ZSkpIHtcbiAgICBjYW5kaWRhdGUgPSBgJHtuYW1lfSR7Y291bnRlcisrfWA7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn1cblxuZnVuY3Rpb24gbmFtZShub2RlOiB0LlN0cmluZ0xpdGVyYWwgfCB0LklkZW50aWZpZXIpOiBzdHJpbmcge1xuICBpZiAobm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2lyZWROYW1lKFxuICBuYW1lSGludDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBleHBvcnRlZE5hbWU6IHN0cmluZyxcbiAgZGVmYXVsdE5hbWVIaW50OiBzdHJpbmcgfCB1bmRlZmluZWRcbikge1xuICBpZiAobmFtZUhpbnQpIHtcbiAgICAvLyBmaXJzdCB3ZSBvcHBvcnR1bmlzdGljYWxseSBkbyBjYW1lbGl6YXRpb24gd2hlbiBhbiBpbGxlZ2FsIGNoYXJhY3RlciBpc1xuICAgIC8vIGZvbGxvd2VkIGJ5IGEgbG93ZXJjYXNlIGxldHRlciwgaW4gYW4gZWZmb3J0IHRvIGFpZCByZWFkYWJpbGl0eSBvZiB0aGVcbiAgICAvLyBvdXRwdXQuXG4gICAgbGV0IGNsZWFuZWQgPSBuYW1lSGludC5yZXBsYWNlKC9bXmEtekEtWl9dKFthLXpdKS9nLCAoX20sIGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpO1xuICAgIC8vIHRoZW4gd2UgdW5saXRlcmFsbHkgc3RyaXAgYWxsIHJlbWFpbmluZyBpbGxlZ2FsIGNoYXJhY3RlcnMuXG4gICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvW15hLXpBLVpfXS9nLCAnJyk7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgaWYgKGV4cG9ydGVkTmFtZSA9PT0gJ2RlZmF1bHQnIHx8IGV4cG9ydGVkTmFtZSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIGRlZmF1bHROYW1lSGludCA/PyAnYSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cG9ydGVkTmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0TmFtZUhpbnQodGFyZ2V0OiBOb2RlUGF0aCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICh0YXJnZXQ/LmlzSWRlbnRpZmllcigpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5ub2RlLm5hbWU7XG4gIH0gZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXJCYXNlZE9uTm9kZSh0YXJnZXQubm9kZSkubmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoU3BlY2lmaWVyKHNwZWM6IE5vZGVQYXRoPGFueT4sIGV4cG9ydGVkTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHN3aXRjaCAoZXhwb3J0ZWROYW1lKSB7XG4gICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICByZXR1cm4gc3BlYy5pc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIoKTtcbiAgICBjYXNlICcqJzpcbiAgICAgIHJldHVybiBzcGVjLmlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzcGVjLmlzSW1wb3J0U3BlY2lmaWVyKCkgJiYgbmFtZShzcGVjLm5vZGUuaW1wb3J0ZWQpID09PSBleHBvcnRlZE5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hNb2R1bGUoXG4gIHBhdGg6IE5vZGVQYXRoPGFueT4sXG4gIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nXG4pOiBwYXRoIGlzIE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+IHtcbiAgcmV0dXJuIHBhdGguaXNJbXBvcnREZWNsYXJhdGlvbigpICYmIHBhdGguZ2V0KCdzb3VyY2UnKS5ub2RlLnZhbHVlID09PSBtb2R1bGVTcGVjaWZpZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0ZXIge1xuICAvLyBJbXBvcnQgdGhlIGdpdmVuIHZhbHVlIChpZiBuZWVkZWQpIGFuZCByZXR1cm4gYW4gSWRlbnRpZmllciByZXByZXNlbnRpbmdcbiAgLy8gaXQuXG4gIGltcG9ydChcbiAgICAvLyB0aGUgcGF0aCB0byB0aGUgbW9kdWxlIHlvdSdyZSBpbXBvcnRpbmcgZnJvbVxuICAgIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLFxuXG4gICAgLy8gdGhlIG5hbWUgeW91J3JlIGltcG9ydGluZyBmcm9tIHRoYXQgbW9kdWxlLiBVc2UgXCJkZWZhdWx0XCIgZm9yIHRoZSBkZWZhdWx0XG4gICAgLy8gZXhwb3J0LiBVc2UgXCIqXCIgZm9yIHRoZSBuYW1lc3BhY2UuXG4gICAgZXhwb3J0ZWROYW1lOiBzdHJpbmcsXG5cbiAgICAvLyBPcHRpb25hbCBoaW50IGZvciBoZWxwaW5nIHVzIHBpY2sgYSBuYW1lIGZvciB0aGUgaW1wb3J0ZWQgYmluZGluZ1xuICAgIG5hbWVIaW50Pzogc3RyaW5nXG4gICk6IHQuSWRlbnRpZmllcjtcbn1cbiJdfQ==