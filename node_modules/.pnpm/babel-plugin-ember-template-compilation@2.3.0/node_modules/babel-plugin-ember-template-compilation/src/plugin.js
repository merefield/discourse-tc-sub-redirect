"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePlugin = makePlugin;
const babel_import_util_1 = require("babel-import-util");
const expression_parser_1 = require("./expression-parser");
const js_utils_1 = require("./js-utils");
const scope_locals_1 = require("./scope-locals");
const syntax_1 = require("@glimmer/syntax");
__exportStar(require("./public-types"), exports);
const INLINE_PRECOMPILE_MODULES = [
    {
        moduleName: 'ember-cli-htmlbars',
        export: 'hbs',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'ember-cli-htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: '@ember/template-compilation',
        export: 'precompileTemplate',
        enableScope: true,
    },
    {
        moduleName: '@ember/template-compiler',
        export: 'template',
        enableScope: true,
        rfc931Support: 'polyfilled',
    },
];
function normalizeOpts(options) {
    var _a;
    if (((_a = options.targetFormat) !== null && _a !== void 0 ? _a : 'wire') === 'wire') {
        let { compiler } = options;
        if (!compiler) {
            throw new Error(`when targetFormat==="wire" you must set the compiler or compilerPath option`);
        }
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'wire', compiler });
    }
    else {
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'hbs' });
    }
}
function makePlugin(loadOptions) {
    return function htmlbarsInlinePrecompile(babel) {
        let t = babel.types;
        const plugin = {
            visitor: {
                Program: {
                    enter(path, state) {
                        state.normalizedOpts = normalizeOpts(loadOptions(state.opts));
                        state.templateFactory = templateFactoryConfig(state.normalizedOpts);
                        state.util = new babel_import_util_1.ImportUtil(babel, path);
                        state.program = path;
                        state.recursionGuard = new Set();
                    },
                    exit(_path, state) {
                        if (state.normalizedOpts.targetFormat === 'wire') {
                            for (let { moduleName, export: exportName } of configuredModules(state)) {
                                state.util.removeImport(moduleName, exportName);
                            }
                        }
                    },
                },
                TaggedTemplateExpression(path, state) {
                    let tagPath = path.get('tag');
                    if (!tagPath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(tagPath, state);
                    if (!config) {
                        return;
                    }
                    if (!config.allowTemplateLiteral) {
                        throw path.buildCodeFrameError(`Attempted to use \`${tagPath.node.name}\` as a template tag, but it can only be called as a function with a string passed to it: ${tagPath.node.name}('content here')`);
                    }
                    if (path.node.quasi.expressions.length) {
                        throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');
                    }
                    let template = path.node.quasi.quasis.map((quasi) => quasi.value.cooked).join('');
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, {}, config, undefined);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, {}, config, undefined);
                    }
                },
                CallExpression(path, state) {
                    let calleePath = path.get('callee');
                    if (!calleePath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(calleePath, state);
                    if (!config) {
                        return;
                    }
                    if (state.recursionGuard.has(path.node)) {
                        return;
                    }
                    if (path.get('arguments').length > 2) {
                        throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string and any static options`);
                    }
                    let [firstArg, secondArg] = path.get('arguments');
                    let template;
                    switch (firstArg === null || firstArg === void 0 ? void 0 : firstArg.node.type) {
                        case 'StringLiteral':
                            template = firstArg.node.value;
                            break;
                        case 'TemplateLiteral':
                            if (firstArg.node.expressions.length) {
                                throw path.buildCodeFrameError('placeholders inside a template string are not supported');
                            }
                            else {
                                template = firstArg.node.quasis.map((quasi) => quasi.value.cooked).join('');
                            }
                            break;
                        case 'TaggedTemplateExpression':
                            throw path.buildCodeFrameError(`tagged template strings inside ${calleePath.node.name} are not supported`);
                        default:
                            throw path.buildCodeFrameError(`${calleePath.node.name} should be invoked with at least a single argument (the template string)`);
                    }
                    let userTypedOptions;
                    let backingClass;
                    if (!secondArg) {
                        userTypedOptions = {};
                    }
                    else {
                        if (!secondArg.isObjectExpression()) {
                            throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                        }
                        userTypedOptions = new expression_parser_1.ExpressionParser(babel).parseObjectExpression(calleePath.node.name, secondArg, config.enableScope, Boolean(config.rfc931Support));
                        if (config.rfc931Support && userTypedOptions.component) {
                            backingClass = userTypedOptions.component;
                        }
                    }
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, userTypedOptions, config, backingClass);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, userTypedOptions, config, backingClass);
                    }
                },
            },
        };
        return {
            pre(file) {
                // run our processing in pre so that imports for gts
                // are kept for other plugins.
                babel.traverse(file.ast, plugin.visitor, file.scope, this);
            },
            visitor: {},
        };
    };
}
function* configuredModules(state) {
    for (let moduleConfig of INLINE_PRECOMPILE_MODULES) {
        if (moduleConfig.moduleName !== '@ember/template-compilation' &&
            moduleConfig.moduleName !== '@ember/template-compiler' &&
            !state.normalizedOpts.enableLegacyModules.includes(moduleConfig.moduleName)) {
            continue;
        }
        yield moduleConfig;
    }
}
function referencesInlineCompiler(path, state) {
    for (let moduleConfig of configuredModules(state)) {
        if (path.referencesImport(moduleConfig.moduleName, moduleConfig.export)) {
            return moduleConfig;
        }
    }
    return undefined;
}
function runtimeErrorIIFE(babel, replacements) {
    let statement = babel.template(`(function() {\n  throw new Error('ERROR_MESSAGE');\n})();`)(replacements);
    return statement.expression;
}
function buildScopeLocals(userTypedOptions, formatOptions, target) {
    if (formatOptions.rfc931Support && userTypedOptions.eval) {
        return new scope_locals_1.ScopeLocals({ mode: 'implicit', jsPath: target });
    }
    else if (userTypedOptions.scope) {
        return userTypedOptions.scope;
    }
    else {
        return new scope_locals_1.ScopeLocals({ mode: 'explicit' });
    }
}
function buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scope) {
    let jsutils = new js_utils_1.JSUtils(babel, state, target, scope.add.bind(scope), state.util);
    let meta = Object.assign({ jsutils }, userTypedOptions === null || userTypedOptions === void 0 ? void 0 : userTypedOptions.meta);
    let output = {
        contents: template,
        // we've extended meta to add jsutils, but the types in @glimmer/syntax
        // don't account for extension
        meta: meta,
        // TODO: embroider's template-compiler allows this to be overriden to get
        // backward-compatible module names that don't match the real name of the
        // on-disk file. What's our plan for migrating people away from that?
        moduleName: state.filename,
        // This is here so it's *always* the real filename. Historically, there is
        // also `moduleName` but that did not match the real on-disk filename, it
        // was the notional runtime module name from classic ember builds.
        filename: state.filename,
        plugins: {
            // the cast is needed here only because our meta is extended. That is,
            // these plugins can access meta.jsutils.
            ast: [...state.normalizedOpts.transforms, scope.crawl()],
        },
    };
    for (let [key, value] of Object.entries(userTypedOptions)) {
        if (key !== 'scope') {
            // `scope` in the user-facing API becomes `locals` in the low-level
            // ember-template-compiler API
            output[key] = value;
        }
    }
    output.locals = scope.locals;
    if (config.rfc931Support) {
        output.strictMode = true;
    }
    return output;
}
function remapAndBindIdentifiers(target, babel, scopeLocals) {
    target.traverse({
        Identifier(path) {
            var _a;
            if (scopeLocals.has(path.node.name) && path.node.name !== scopeLocals.get(path.node.name)) {
                // this identifier has different names in hbs vs js, so we need to
                // replace the hbs name in the template compiler output with the js
                // name
                path.replaceWith(babel.types.identifier(scopeLocals.get(path.node.name)));
            }
            // this is where we tell babel's scope system about the new reference we
            // just introduced. @babel/plugin-transform-typescript in particular
            // cares a lot about those references being present.
            (_a = path.scope.getBinding(path.node.name)) === null || _a === void 0 ? void 0 : _a.reference(path);
        },
    });
}
function insertCompiledTemplate(babel, state, opts, template, target, userTypedOptions, config, backingClass) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, config, target);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scopeLocals);
    let precompileResultString;
    // insertRuntimeErrors is legacy and not supported by the newer rfc931 form
    if (options.insertRuntimeErrors && !config.rfc931Support) {
        try {
            precompileResultString = opts.compiler.precompile(template, options);
        }
        catch (error) {
            target.replaceWith(runtimeErrorIIFE(babel, { ERROR_MESSAGE: error.message }));
            return;
        }
    }
    else {
        precompileResultString = opts.compiler.precompile(template, options);
    }
    let templateExpression = babel.template.expression.ast(precompileResultString);
    t.addComment(templateExpression, 'leading', `\n  ${template.replace(/\*\//g, '*\\/')}\n`, 
    /* line comment? */ false);
    state.util.replaceWith(target, (i) => {
        var _a;
        let templateFactoryIdentifier = i.import(state.templateFactory.moduleName, state.templateFactory.exportName);
        let expression = t.callExpression(templateFactoryIdentifier, [templateExpression]);
        if (config.rfc931Support) {
            expression = t.callExpression(i.import('@ember/component', 'setComponentTemplate'), [
                expression,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : t.callExpression(i.import('@ember/component/template-only', 'default', 'templateOnly'), []),
            ]);
        }
        return expression;
    });
    remapAndBindIdentifiers(target, babel, scopeLocals);
}
function insertTransformedTemplate(babel, state, template, target, userTypedOptions, formatOptions, backingClass) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, formatOptions, target);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, formatOptions, scopeLocals);
    let ast = (0, syntax_1.preprocess)(template, Object.assign(Object.assign({}, options), { mode: 'codemod' }));
    let transformed = (0, syntax_1.print)(ast, { entityEncoding: 'raw' });
    if (target.isCallExpression()) {
        updateCallForm(target, transformed, formatOptions, scopeLocals, state, babel, backingClass);
    }
    else {
        updateBacktickForm(scopeLocals, state, target, t, transformed, babel);
    }
}
function updateBacktickForm(scopeLocals, state, target, t, transformed, babel) {
    if (scopeLocals.isEmpty()) {
        // simple case: just replace the string literal part with the transformed
        // template contents
        target.get('quasi').get('quasis.0').replaceWith(t.templateElement({ raw: transformed }));
        return;
    }
    // need to add scope, so need to replace the backticks form with a call
    // expression to precompileTemplate
    maybePruneImport(state.util, target.get('tag'));
    let newCall = state.util.replaceWith(target, (i) => t.callExpression(precompileTemplate(i), [t.stringLiteral(transformed)]));
    updateScope(babel, newCall, scopeLocals);
}
function updateCallForm(target, transformed, formatOptions, scopeLocals, state, babel, backingClass) {
    // first the simple part: replacing the string literal with the actual body of
    // the rewritten template
    target.get('arguments.0').replaceWith(babel.types.stringLiteral(transformed));
    if (!formatOptions.enableScope && !scopeLocals.isEmpty()) {
        // an AST transform added lexically scoped values to a template that
        // wasn't already in a form that supports them, so convert form.
        maybePruneImport(state.util, target.get('callee'));
        state.util.replaceWith(target.get('callee'), (i) => precompileTemplate(i));
    }
    if (formatOptions.rfc931Support === 'polyfilled') {
        maybePruneImport(state.util, target.get('callee'));
        state.util.replaceWith(target.get('callee'), (i) => precompileTemplate(i));
        convertStrictMode(babel, target);
        removeEvalAndScope(target);
        target.node.arguments = target.node.arguments.slice(0, 2);
        state.recursionGuard.add(target.node);
        state.util.replaceWith(target, (i) => {
            var _a;
            return babel.types.callExpression(i.import('@ember/component', 'setComponentTemplate'), [
                target.node,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : babel.types.callExpression(i.import('@ember/component/template-only', 'default', 'templateOnly'), []),
            ]);
        });
        // we just wrapped the target callExpression in the call to
        // setComponentTemplate. Adjust `target` back to point at the
        // precompileTemplate call for the final updateScope below.
        //
        target = target.get('arguments.0');
    }
    // We deliberately do updateScope at the end so that when it updates
    // references, those references will point to the accurate paths in the
    // final AST.
    updateScope(babel, target, scopeLocals);
}
function templateFactoryConfig(opts) {
    var _a;
    let moduleName = '@ember/template-factory';
    let exportName = 'createTemplateFactory';
    let overrides = (_a = opts.outputModuleOverrides[moduleName]) === null || _a === void 0 ? void 0 : _a[exportName];
    return overrides
        ? { exportName: overrides[0], moduleName: overrides[1] }
        : { exportName, moduleName };
}
function buildScope(babel, locals) {
    let t = babel.types;
    return t.arrowFunctionExpression([], t.objectExpression(locals
        .entries()
        .map(([name, identifier]) => t.objectProperty(t.identifier(name), t.identifier(identifier), false, true))));
}
// this is responsible both for adjusting the AST for our scope argument *and*
// ensuring that babel's scope system will see that these new identifiers
// reference their bindings. @babel/plugin-transform-typescript in particular
// cares an awful lot about whether an import has valid non-type references, so
// these newly introducd references need to be valid.
function updateScope(babel, target, locals) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let scope = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'scope';
        });
        if (scope) {
            if (locals.isEmpty()) {
                scope.remove();
            }
            else {
                scope.set('value', buildScope(babel, locals));
                // funny-looking naming here, but it actually makes sense because we're
                // connecting the glimmer scope system with the babel scope system.
                scope.scope.crawl();
            }
        }
        else if (!locals.isEmpty()) {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('scope'), buildScope(babel, locals)));
            secondArg.get(`properties.${secondArg.node.properties.length - 1}`).scope.crawl();
        }
    }
    else if (!locals.isEmpty()) {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('scope'), buildScope(babel, locals))]));
        target.get('arguments.1').scope.crawl();
    }
}
function removeEvalAndScope(target) {
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let evalProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'eval';
        });
        if (evalProp) {
            evalProp.remove();
        }
        let componentProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'component';
        });
        if (componentProp) {
            componentProp.remove();
        }
    }
}
// Given a call to template(), convert its "strict" argument into
// precompileTemplate's "strictMode" argument. They differ in name and default
// value.
function convertStrictMode(babel, target) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let strict = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'strict';
        });
        if (strict) {
            strict.set('key', t.identifier('strictMode'));
        }
        else {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true)));
        }
    }
    else {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true))]));
    }
}
function maybePruneImport(util, identifier) {
    if (!identifier.isIdentifier()) {
        return;
    }
    let binding = identifier.scope.getBinding(identifier.node.name);
    if (!binding) {
        return;
    }
    let found = binding.referencePaths.find((path) => path.node === identifier.node);
    if (!found) {
        return;
    }
    binding.referencePaths.splice(binding.referencePaths.indexOf(found), 1);
    binding.references--;
    if (binding.references === 0) {
        let specifier = binding.path;
        if (specifier.isImportSpecifier()) {
            let declaration = specifier.parentPath;
            util.removeImport(declaration.node.source.value, name(specifier.node.imported));
        }
    }
}
function precompileTemplate(i) {
    return i.import('@ember/template-compilation', 'precompileTemplate');
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
exports.default = makePlugin((options) => options);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1SkEsZ0NBZ0xDO0FBcFVELHlEQUE4RDtBQUM5RCwyREFBdUQ7QUFDdkQseUNBQTREO0FBRzVELGlEQUE2QztBQUM3Qyw0Q0FBc0U7QUFFdEUsaURBQStCO0FBWS9CLE1BQU0seUJBQXlCLEdBQW1CO0lBQ2hEO1FBQ0UsVUFBVSxFQUFFLG9CQUFvQjtRQUNoQyxNQUFNLEVBQUUsS0FBSztRQUNiLG9CQUFvQixFQUFFLElBQUk7S0FDM0I7SUFDRDtRQUNFLFVBQVUsRUFBRSxzQ0FBc0M7UUFDbEQsTUFBTSxFQUFFLFNBQVM7UUFDakIsb0JBQW9CLEVBQUUsSUFBSTtLQUMzQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLDRCQUE0QjtRQUN4QyxNQUFNLEVBQUUsU0FBUztRQUNqQixvQkFBb0IsRUFBRSxJQUFJO0tBQzNCO0lBQ0Q7UUFDRSxVQUFVLEVBQUUsNkJBQTZCO1FBQ3pDLE1BQU0sRUFBRSxvQkFBb0I7UUFDNUIsV0FBVyxFQUFFLElBQUk7S0FDbEI7SUFDRDtRQUNFLFVBQVUsRUFBRSwwQkFBMEI7UUFDdEMsTUFBTSxFQUFFLFVBQVU7UUFDbEIsV0FBVyxFQUFFLElBQUk7UUFDakIsYUFBYSxFQUFFLFlBQVk7S0FDNUI7Q0FDRixDQUFDO0FBK0RGLFNBQVMsYUFBYSxDQUFDLE9BQWdCOztJQUNyQyxJQUFJLENBQUMsTUFBQSxPQUFPLENBQUMsWUFBWSxtQ0FBSSxNQUFNLENBQUMsS0FBSyxNQUFNLEVBQUUsQ0FBQztRQUNoRCxJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNkLE1BQU0sSUFBSSxLQUFLLENBQ2IsNkVBQTZFLENBQzlFLENBQUM7UUFDSixDQUFDO1FBQ0QscUNBQ0UscUJBQXFCLEVBQUUsRUFBRSxFQUN6QixtQkFBbUIsRUFBRSxFQUFFLEVBQ3ZCLFVBQVUsRUFBRSxFQUFFLElBQ1gsT0FBTyxLQUNWLFlBQVksRUFBRSxNQUFNLEVBQ3BCLFFBQVEsSUFDUjtJQUNKLENBQUM7U0FBTSxDQUFDO1FBQ04scUNBQ0UscUJBQXFCLEVBQUUsRUFBRSxFQUN6QixtQkFBbUIsRUFBRSxFQUFFLEVBQ3ZCLFVBQVUsRUFBRSxFQUFFLElBQ1gsT0FBTyxLQUNWLFlBQVksRUFBRSxLQUFLLElBQ25CO0lBQ0osQ0FBQztBQUNILENBQUM7QUFhRCxTQUFnQixVQUFVLENBQXFCLFdBQWtEO0lBQy9GLE9BQU8sU0FBUyx3QkFBd0IsQ0FDdEMsS0FBbUI7UUFFbkIsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUVwQixNQUFNLE1BQU0sR0FBRztZQUNiLE9BQU8sRUFBRTtnQkFDUCxPQUFPLEVBQUU7b0JBQ1AsS0FBSyxDQUFDLElBQXlCLEVBQUUsS0FBZ0M7d0JBQy9ELEtBQUssQ0FBQyxjQUFjLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzt3QkFDOUQsS0FBSyxDQUFDLGVBQWUsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7d0JBQ3BFLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSw4QkFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQzt3QkFDekMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7d0JBQ3JCLEtBQUssQ0FBQyxjQUFjLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztvQkFDbkMsQ0FBQztvQkFDRCxJQUFJLENBQUMsS0FBMEIsRUFBRSxLQUFnQzt3QkFDL0QsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLFlBQVksS0FBSyxNQUFNLEVBQUUsQ0FBQzs0QkFDakQsS0FBSyxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2dDQUN4RSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUM7NEJBQ2xELENBQUM7d0JBQ0gsQ0FBQztvQkFDSCxDQUFDO2lCQUNGO2dCQUVELHdCQUF3QixDQUN0QixJQUEwQyxFQUMxQyxLQUFnQztvQkFFaEMsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFFOUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDO3dCQUM1QixPQUFPO29CQUNULENBQUM7b0JBQ0QsSUFBSSxNQUFNLEdBQUcsd0JBQXdCLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUN0RCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7d0JBQ1osT0FBTztvQkFDVCxDQUFDO29CQUVELElBQUksQ0FBQyxNQUFNLENBQUMsb0JBQW9CLEVBQUUsQ0FBQzt3QkFDakMsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQzVCLHNCQUFzQixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksNkZBQTZGLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxrQkFBa0IsQ0FDeEssQ0FBQztvQkFDSixDQUFDO29CQUVELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDO3dCQUN2QyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FDNUIsZ0VBQWdFLENBQ2pFLENBQUM7b0JBQ0osQ0FBQztvQkFFRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDbEYsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLFlBQVksS0FBSyxNQUFNLEVBQUUsQ0FBQzt3QkFDakQsc0JBQXNCLENBQ3BCLEtBQUssRUFDTCxLQUFLLEVBQ0wsS0FBSyxDQUFDLGNBQWMsRUFDcEIsUUFBUSxFQUNSLElBQUksRUFDSixFQUFFLEVBQ0YsTUFBTSxFQUNOLFNBQVMsQ0FDVixDQUFDO29CQUNKLENBQUM7eUJBQU0sQ0FBQzt3QkFDTix5QkFBeUIsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztvQkFDakYsQ0FBQztnQkFDSCxDQUFDO2dCQUVELGNBQWMsQ0FBQyxJQUFnQyxFQUFFLEtBQWdDO29CQUMvRSxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUVwQyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUM7d0JBQy9CLE9BQU87b0JBQ1QsQ0FBQztvQkFDRCxJQUFJLE1BQU0sR0FBRyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7b0JBQ3pELElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQzt3QkFDWixPQUFPO29CQUNULENBQUM7b0JBRUQsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQzt3QkFDeEMsT0FBTztvQkFDVCxDQUFDO29CQUVELElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7d0JBQ3JDLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUM1QixHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxtRkFBbUYsQ0FDM0csQ0FBQztvQkFDSixDQUFDO29CQUVELElBQUksQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFFbEQsSUFBSSxRQUFRLENBQUM7b0JBRWIsUUFBUSxRQUFRLGFBQVIsUUFBUSx1QkFBUixRQUFRLENBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO3dCQUM1QixLQUFLLGVBQWU7NEJBQ2xCLFFBQVEsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQzs0QkFDL0IsTUFBTTt3QkFDUixLQUFLLGlCQUFpQjs0QkFDcEIsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQ0FDckMsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQzVCLHlEQUF5RCxDQUMxRCxDQUFDOzRCQUNKLENBQUM7aUNBQU0sQ0FBQztnQ0FDTixRQUFRLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQzs0QkFDOUUsQ0FBQzs0QkFDRCxNQUFNO3dCQUNSLEtBQUssMEJBQTBCOzRCQUM3QixNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FDNUIsa0NBQWtDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxvQkFBb0IsQ0FDM0UsQ0FBQzt3QkFDSjs0QkFDRSxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FDNUIsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksMEVBQTBFLENBQ2xHLENBQUM7b0JBQ04sQ0FBQztvQkFFRCxJQUFJLGdCQUF5QyxDQUFDO29CQUM5QyxJQUFJLFlBQWtGLENBQUM7b0JBRXZGLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQzt3QkFDZixnQkFBZ0IsR0FBRyxFQUFFLENBQUM7b0JBQ3hCLENBQUM7eUJBQU0sQ0FBQzt3QkFDTixJQUFJLENBQUMsU0FBUyxDQUFDLGtCQUFrQixFQUFFLEVBQUUsQ0FBQzs0QkFDcEMsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQzVCLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLG9GQUFvRixDQUM1RyxDQUFDO3dCQUNKLENBQUM7d0JBRUQsZ0JBQWdCLEdBQUcsSUFBSSxvQ0FBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxxQkFBcUIsQ0FDbEUsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQ3BCLFNBQVMsRUFDVCxNQUFNLENBQUMsV0FBVyxFQUNsQixPQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUM5QixDQUFDO3dCQUNGLElBQUksTUFBTSxDQUFDLGFBQWEsSUFBSSxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsQ0FBQzs0QkFDdkQsWUFBWSxHQUFHLGdCQUFnQixDQUFDLFNBRS9CLENBQUM7d0JBQ0osQ0FBQztvQkFDSCxDQUFDO29CQUVELElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEtBQUssTUFBTSxFQUFFLENBQUM7d0JBQ2pELHNCQUFzQixDQUNwQixLQUFLLEVBQ0wsS0FBSyxFQUNMLEtBQUssQ0FBQyxjQUFjLEVBQ3BCLFFBQVEsRUFDUixJQUFJLEVBQ0osZ0JBQWdCLEVBQ2hCLE1BQU0sRUFDTixZQUFZLENBQ2IsQ0FBQztvQkFDSixDQUFDO3lCQUFNLENBQUM7d0JBQ04seUJBQXlCLENBQ3ZCLEtBQUssRUFDTCxLQUFLLEVBQ0wsUUFBUSxFQUNSLElBQUksRUFDSixnQkFBZ0IsRUFDaEIsTUFBTSxFQUNOLFlBQVksQ0FDYixDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQzthQUNGO1NBQ0YsQ0FBQztRQUVGLE9BQU87WUFDTCxHQUFHLENBQWtDLElBQUk7Z0JBQ3ZDLG9EQUFvRDtnQkFDcEQsOEJBQThCO2dCQUM5QixLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzdELENBQUM7WUFDRCxPQUFPLEVBQUUsRUFBRTtTQUNaLENBQUM7SUFDSixDQUFzRCxDQUFDO0FBQ3pELENBQUM7QUFFRCxRQUFRLENBQUMsQ0FBQyxpQkFBaUIsQ0FBcUIsS0FBZ0M7SUFDOUUsS0FBSyxJQUFJLFlBQVksSUFBSSx5QkFBeUIsRUFBRSxDQUFDO1FBQ25ELElBQ0UsWUFBWSxDQUFDLFVBQVUsS0FBSyw2QkFBNkI7WUFDekQsWUFBWSxDQUFDLFVBQVUsS0FBSywwQkFBMEI7WUFDdEQsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQzNFLENBQUM7WUFDRCxTQUFTO1FBQ1gsQ0FBQztRQUNELE1BQU0sWUFBWSxDQUFDO0lBQ3JCLENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBUyx3QkFBd0IsQ0FDL0IsSUFBNEIsRUFDNUIsS0FBZ0M7SUFFaEMsS0FBSyxJQUFJLFlBQVksSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ2xELElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7WUFDeEUsT0FBTyxZQUFZLENBQUM7UUFDdEIsQ0FBQztJQUNILENBQUM7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxLQUFtQixFQUFFLFlBQXVDO0lBQ3BGLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsMkRBQTJELENBQUMsQ0FDekYsWUFBWSxDQUNZLENBQUM7SUFDM0IsT0FBTyxTQUFTLENBQUMsVUFBVSxDQUFDO0FBQzlCLENBQUM7QUFFRCxTQUFTLGdCQUFnQixDQUN2QixnQkFBeUMsRUFDekMsYUFBMkIsRUFDM0IsTUFBOEI7SUFFOUIsSUFBSSxhQUFhLENBQUMsYUFBYSxJQUFJLGdCQUFnQixDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3pELE9BQU8sSUFBSSwwQkFBVyxDQUFDLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUMvRCxDQUFDO1NBQU0sSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNsQyxPQUFPLGdCQUFnQixDQUFDLEtBQW9CLENBQUM7SUFDL0MsQ0FBQztTQUFNLENBQUM7UUFDTixPQUFPLElBQUksMEJBQVcsQ0FBQyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBQy9DLENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FDN0IsS0FBbUIsRUFDbkIsTUFBOEIsRUFDOUIsS0FBZ0MsRUFDaEMsUUFBZ0IsRUFDaEIsZ0JBQXlDLEVBQ3pDLE1BQW9CLEVBQ3BCLEtBQWtCO0lBRWxCLElBQUksT0FBTyxHQUFHLElBQUksa0JBQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbkYsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLGdCQUFnQixhQUFoQixnQkFBZ0IsdUJBQWhCLGdCQUFnQixDQUFFLElBQUksQ0FBQyxDQUFDO0lBRTlELElBQUksTUFBTSxHQUFnRDtRQUN4RCxRQUFRLEVBQUUsUUFBUTtRQUVsQix1RUFBdUU7UUFDdkUsOEJBQThCO1FBQzlCLElBQUksRUFBRSxJQUFpQztRQUV2Qyx5RUFBeUU7UUFDekUseUVBQXlFO1FBQ3pFLHFFQUFxRTtRQUNyRSxVQUFVLEVBQUUsS0FBSyxDQUFDLFFBQVE7UUFFMUIsMEVBQTBFO1FBQzFFLHlFQUF5RTtRQUN6RSxrRUFBa0U7UUFDbEUsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO1FBRXhCLE9BQU8sRUFBRTtZQUNQLHNFQUFzRTtZQUN0RSx5Q0FBeUM7WUFDekMsR0FBRyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQXVCO1NBQy9FO0tBQ0YsQ0FBQztJQUVGLEtBQUssSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztRQUMxRCxJQUFJLEdBQUcsS0FBSyxPQUFPLEVBQUUsQ0FBQztZQUNwQixtRUFBbUU7WUFDbkUsOEJBQThCO1lBQzlCLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7UUFDdEIsQ0FBQztJQUNILENBQUM7SUFFRCxNQUFNLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFFN0IsSUFBSSxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDekIsTUFBTSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7SUFDM0IsQ0FBQztJQUVELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxTQUFTLHVCQUF1QixDQUFDLE1BQWdCLEVBQUUsS0FBbUIsRUFBRSxXQUF3QjtJQUM5RixNQUFNLENBQUMsUUFBUSxDQUFDO1FBQ2QsVUFBVSxDQUFDLElBQTRCOztZQUNyQyxJQUFJLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDMUYsa0VBQWtFO2dCQUNsRSxtRUFBbUU7Z0JBQ25FLE9BQU87Z0JBQ1AsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVFLENBQUM7WUFDRCx3RUFBd0U7WUFDeEUsb0VBQW9FO1lBQ3BFLG9EQUFvRDtZQUNwRCxNQUFBLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLDBDQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6RCxDQUFDO0tBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsc0JBQXNCLENBQzdCLEtBQW1CLEVBQ25CLEtBQWdDLEVBQ2hDLElBQWMsRUFDZCxRQUFnQixFQUNoQixNQUE4QixFQUM5QixnQkFBeUMsRUFDekMsTUFBb0IsRUFDcEIsWUFBa0Y7SUFFbEYsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztJQUNwQixJQUFJLFdBQVcsR0FBRyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDckUsSUFBSSxPQUFPLEdBQUcsc0JBQXNCLENBQ2xDLEtBQUssRUFDTCxNQUFNLEVBQ04sS0FBSyxFQUNMLFFBQVEsRUFDUixnQkFBZ0IsRUFDaEIsTUFBTSxFQUNOLFdBQVcsQ0FDWixDQUFDO0lBRUYsSUFBSSxzQkFBOEIsQ0FBQztJQUVuQywyRUFBMkU7SUFDM0UsSUFBSSxPQUFPLENBQUMsbUJBQW1CLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDekQsSUFBSSxDQUFDO1lBQ0gsc0JBQXNCLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZFLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsTUFBTSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsRUFBRSxhQUFhLEVBQUcsS0FBYSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN2RixPQUFPO1FBQ1QsQ0FBQztJQUNILENBQUM7U0FBTSxDQUFDO1FBQ04sc0JBQXNCLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRCxJQUFJLGtCQUFrQixHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBRS9FLENBQUMsQ0FBQyxVQUFVLENBQ1Ysa0JBQWtCLEVBQ2xCLFNBQVMsRUFDVCxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxJQUFJO0lBQzVDLG1CQUFtQixDQUFDLEtBQUssQ0FDMUIsQ0FBQztJQUVGLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFOztRQUNuQyxJQUFJLHlCQUF5QixHQUFHLENBQUMsQ0FBQyxNQUFNLENBQ3RDLEtBQUssQ0FBQyxlQUFlLENBQUMsVUFBVSxFQUNoQyxLQUFLLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FDakMsQ0FBQztRQUVGLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQyxjQUFjLENBQUMseUJBQXlCLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7UUFFbkYsSUFBSSxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDekIsVUFBVSxHQUFHLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxzQkFBc0IsQ0FBQyxFQUFFO2dCQUNsRixVQUFVO2dCQUNWLE1BQUEsWUFBWSxhQUFaLFlBQVksdUJBQVosWUFBWSxDQUFFLElBQUksbUNBQ2hCLENBQUMsQ0FBQyxjQUFjLENBQ2QsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxnQ0FBZ0MsRUFBRSxTQUFTLEVBQUUsY0FBYyxDQUFDLEVBQ3JFLEVBQUUsQ0FDSDthQUNKLENBQUMsQ0FBQztRQUNMLENBQUM7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDLENBQUMsQ0FBQztJQUVILHVCQUF1QixDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDdEQsQ0FBQztBQUVELFNBQVMseUJBQXlCLENBQ2hDLEtBQW1CLEVBQ25CLEtBQWdDLEVBQ2hDLFFBQWdCLEVBQ2hCLE1BQXlFLEVBQ3pFLGdCQUF5QyxFQUN6QyxhQUEyQixFQUMzQixZQUFrRjtJQUVsRixJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO0lBQ3BCLElBQUksV0FBVyxHQUFHLGdCQUFnQixDQUFDLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM1RSxJQUFJLE9BQU8sR0FBRyxzQkFBc0IsQ0FDbEMsS0FBSyxFQUNMLE1BQU0sRUFDTixLQUFLLEVBQ0wsUUFBUSxFQUNSLGdCQUFnQixFQUNoQixhQUFhLEVBQ2IsV0FBVyxDQUNaLENBQUM7SUFDRixJQUFJLEdBQUcsR0FBRyxJQUFBLG1CQUFVLEVBQUMsUUFBUSxrQ0FBTyxPQUFPLEtBQUUsSUFBSSxFQUFFLFNBQVMsSUFBRyxDQUFDO0lBQ2hFLElBQUksV0FBVyxHQUFHLElBQUEsY0FBSyxFQUFDLEdBQUcsRUFBRSxFQUFFLGNBQWMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBRXhELElBQUksTUFBTSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQztRQUM5QixjQUFjLENBQ1osTUFBTSxFQUNOLFdBQVcsRUFDWCxhQUFhLEVBQ2IsV0FBVyxFQUNYLEtBQUssRUFDTCxLQUFLLEVBQ0wsWUFBWSxDQUNiLENBQUM7SUFDSixDQUFDO1NBQU0sQ0FBQztRQUNOLGtCQUFrQixDQUFxQixXQUFXLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzVGLENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FDekIsV0FBd0IsRUFDeEIsS0FBZ0MsRUFDaEMsTUFBNEMsRUFDNUMsQ0FBcUIsRUFDckIsV0FBbUIsRUFDbkIsS0FBbUI7SUFFbkIsSUFBSSxXQUFXLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztRQUMxQix5RUFBeUU7UUFDekUsb0JBQW9CO1FBQ25CLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBaUMsQ0FBQyxXQUFXLENBQzlFLENBQUMsQ0FBQyxlQUFlLENBQUMsRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FDeEMsQ0FBQztRQUNGLE9BQU87SUFDVCxDQUFDO0lBRUQsdUVBQXVFO0lBQ3ZFLG1DQUFtQztJQUNuQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNoRCxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNqRCxDQUFDLENBQUMsY0FBYyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQ3hFLENBQUM7SUFDRixXQUFXLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBRUQsU0FBUyxjQUFjLENBQ3JCLE1BQTRDLEVBQzVDLFdBQW1CLEVBQ25CLGFBQTJCLEVBQzNCLFdBQXdCLEVBQ3hCLEtBQWdDLEVBQ2hDLEtBQW1CLEVBQ25CLFlBRWE7SUFFYiw4RUFBOEU7SUFDOUUseUJBQXlCO0lBQ3hCLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFzQixDQUFDLFdBQVcsQ0FDekQsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQ3ZDLENBQUM7SUFFRixJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDO1FBQ3pELG9FQUFvRTtRQUNwRSxnRUFBZ0U7UUFDaEUsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDbkQsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRUQsSUFBSSxhQUFhLENBQUMsYUFBYSxLQUFLLFlBQVksRUFBRSxDQUFDO1FBQ2pELGdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ25ELEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0UsaUJBQWlCLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ2pDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzNCLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDMUQsS0FBSyxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFOztZQUNuQyxPQUFBLEtBQUssQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsc0JBQXNCLENBQUMsRUFBRTtnQkFDL0UsTUFBTSxDQUFDLElBQUk7Z0JBQ1gsTUFBQSxZQUFZLGFBQVosWUFBWSx1QkFBWixZQUFZLENBQUUsSUFBSSxtQ0FDaEIsS0FBSyxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQ3hCLENBQUMsQ0FBQyxNQUFNLENBQUMsZ0NBQWdDLEVBQUUsU0FBUyxFQUFFLGNBQWMsQ0FBQyxFQUNyRSxFQUFFLENBQ0g7YUFDSixDQUFDLENBQUE7U0FBQSxDQUNILENBQUM7UUFDRiwyREFBMkQ7UUFDM0QsNkRBQTZEO1FBQzdELDJEQUEyRDtRQUMzRCxFQUFFO1FBQ0YsTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUErQixDQUFDO0lBQ25FLENBQUM7SUFDRCxvRUFBb0U7SUFDcEUsdUVBQXVFO0lBQ3ZFLGFBQWE7SUFDYixXQUFXLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztBQUMxQyxDQUFDO0FBRUQsU0FBUyxxQkFBcUIsQ0FBQyxJQUFvQjs7SUFDakQsSUFBSSxVQUFVLEdBQUcseUJBQXlCLENBQUM7SUFDM0MsSUFBSSxVQUFVLEdBQUcsdUJBQXVCLENBQUM7SUFDekMsSUFBSSxTQUFTLEdBQUcsTUFBQSxJQUFJLENBQUMscUJBQXFCLENBQUMsVUFBVSxDQUFDLDBDQUFHLFVBQVUsQ0FBQyxDQUFDO0lBQ3JFLE9BQU8sU0FBUztRQUNkLENBQUMsQ0FBQyxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUN4RCxDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLENBQUM7QUFDakMsQ0FBQztBQUVELFNBQVMsVUFBVSxDQUFDLEtBQW1CLEVBQUUsTUFBbUI7SUFDMUQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztJQUVwQixPQUFPLENBQUMsQ0FBQyx1QkFBdUIsQ0FDOUIsRUFBRSxFQUNGLENBQUMsQ0FBQyxnQkFBZ0IsQ0FDaEIsTUFBTTtTQUNILE9BQU8sRUFBRTtTQUNULEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxFQUFFLEVBQUUsQ0FDMUIsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUM1RSxDQUNKLENBQ0YsQ0FBQztBQUNKLENBQUM7QUFFRCw4RUFBOEU7QUFDOUUseUVBQXlFO0FBQ3pFLDZFQUE2RTtBQUM3RSwrRUFBK0U7QUFDL0UscURBQXFEO0FBQ3JELFNBQVMsV0FBVyxDQUFDLEtBQW1CLEVBQUUsTUFBa0MsRUFBRSxNQUFtQjtJQUMvRixJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO0lBQ3BCLElBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUE2QyxDQUFDO0lBQ3RGLElBQUksU0FBUyxFQUFFLENBQUM7UUFDZCxJQUFJLEtBQUssR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ2pELElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFxQixDQUFDO1lBQzNDLE9BQU8sR0FBRyxDQUFDLFlBQVksRUFBRSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQztRQUN6RCxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksS0FBSyxFQUFFLENBQUM7WUFDVixJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDO2dCQUNyQixLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDakIsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDOUMsdUVBQXVFO2dCQUN2RSxtRUFBbUU7Z0JBQ25FLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDdEIsQ0FBQztRQUNILENBQUM7YUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7WUFDN0IsU0FBUyxDQUFDLGFBQWEsQ0FDckIsWUFBWSxFQUNaLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRSxVQUFVLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQ25FLENBQUM7WUFFQSxTQUFTLENBQUMsR0FBRyxDQUNYLGNBQWMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUV2RCxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNsQixDQUFDO0lBQ0gsQ0FBQztTQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztRQUM3QixNQUFNLENBQUMsYUFBYSxDQUNsQixXQUFXLEVBQ1gsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFLFVBQVUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3pGLENBQUM7UUFDRCxNQUFNLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBa0MsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDNUUsQ0FBQztBQUNILENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUFDLE1BQWtDO0lBQzVELElBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUE2QyxDQUFDO0lBQ3RGLElBQUksU0FBUyxFQUFFLENBQUM7UUFDZCxJQUFJLFFBQVEsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ3BELElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFxQixDQUFDO1lBQzNDLE9BQU8sR0FBRyxDQUFDLFlBQVksRUFBRSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQztRQUN4RCxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksUUFBUSxFQUFFLENBQUM7WUFDYixRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDcEIsQ0FBQztRQUVELElBQUksYUFBYSxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDekQsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQXFCLENBQUM7WUFDM0MsT0FBTyxHQUFHLENBQUMsWUFBWSxFQUFFLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssV0FBVyxDQUFDO1FBQzdELENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxhQUFhLEVBQUUsQ0FBQztZQUNsQixhQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDekIsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBRUQsaUVBQWlFO0FBQ2pFLDhFQUE4RTtBQUM5RSxTQUFTO0FBQ1QsU0FBUyxpQkFBaUIsQ0FBQyxLQUFtQixFQUFFLE1BQWtDO0lBQ2hGLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7SUFDcEIsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQTZDLENBQUM7SUFDdEYsSUFBSSxTQUFTLEVBQUUsQ0FBQztRQUNkLElBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDbEQsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQXFCLENBQUM7WUFDM0MsT0FBTyxHQUFHLENBQUMsWUFBWSxFQUFFLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDO1FBQzFELENBQUMsQ0FBK0IsQ0FBQztRQUNqQyxJQUFJLE1BQU0sRUFBRSxDQUFDO1lBQ1gsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ2hELENBQUM7YUFBTSxDQUFDO1lBQ04sU0FBUyxDQUFDLGFBQWEsQ0FDckIsWUFBWSxFQUNaLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQ3JFLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztTQUFNLENBQUM7UUFDTixNQUFNLENBQUMsYUFBYSxDQUNsQixXQUFXLEVBQ1gsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzNGLENBQUM7SUFDSixDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQ3ZCLElBQWdCLEVBQ2hCLFVBQTREO0lBRTVELElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQztRQUMvQixPQUFPO0lBQ1QsQ0FBQztJQUNELElBQUksT0FBTyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFaEUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2IsT0FBTztJQUNULENBQUM7SUFFRCxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakYsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ1gsT0FBTztJQUNULENBQUM7SUFFRCxPQUFPLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4RSxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7SUFFckIsSUFBSSxPQUFPLENBQUMsVUFBVSxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQzdCLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDN0IsSUFBSSxTQUFTLENBQUMsaUJBQWlCLEVBQUUsRUFBRSxDQUFDO1lBQ2xDLElBQUksV0FBVyxHQUFHLFNBQVMsQ0FBQyxVQUEyQyxDQUFDO1lBQ3hFLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDbEYsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FBQyxDQUFXO0lBQ3JDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyw2QkFBNkIsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0FBQ3ZFLENBQUM7QUFFRCxTQUFTLElBQUksQ0FBQyxJQUFvQztJQUNoRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssZUFBZSxFQUFFLENBQUM7UUFDbEMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7U0FBTSxDQUFDO1FBQ04sT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUM7QUFDSCxDQUFDO0FBRUQsa0JBQWUsVUFBVSxDQUFVLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTm9kZVBhdGggfSBmcm9tICdAYmFiZWwvdHJhdmVyc2UnO1xuaW1wb3J0IHR5cGUgKiBhcyBCYWJlbCBmcm9tICdAYmFiZWwvY29yZSc7XG5pbXBvcnQgdHlwZSB7IHR5cGVzIGFzIHQgfSBmcm9tICdAYmFiZWwvY29yZSc7XG5pbXBvcnQgeyBJbXBvcnRVdGlsLCB0eXBlIEltcG9ydGVyIH0gZnJvbSAnYmFiZWwtaW1wb3J0LXV0aWwnO1xuaW1wb3J0IHsgRXhwcmVzc2lvblBhcnNlciB9IGZyb20gJy4vZXhwcmVzc2lvbi1wYXJzZXInO1xuaW1wb3J0IHsgSlNVdGlscywgRXh0ZW5kZWRQbHVnaW5CdWlsZGVyIH0gZnJvbSAnLi9qcy11dGlscyc7XG5pbXBvcnQgdHlwZSB7IEVtYmVyVGVtcGxhdGVDb21waWxlciwgUHJlcHJvY2Vzc09wdGlvbnMgfSBmcm9tICcuL2VtYmVyLXRlbXBsYXRlLWNvbXBpbGVyJztcbmltcG9ydCB7IExlZ2FjeU1vZHVsZU5hbWUgfSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQgeyBTY29wZUxvY2FscyB9IGZyb20gJy4vc2NvcGUtbG9jYWxzJztcbmltcG9ydCB7IEFTVFBsdWdpbkJ1aWxkZXIsIHByZXByb2Nlc3MsIHByaW50IH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcblxuZXhwb3J0ICogZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuXG50eXBlIE1vZHVsZU5hbWUgPSBMZWdhY3lNb2R1bGVOYW1lIHwgJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicgfCAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGVyJztcblxuaW50ZXJmYWNlIE1vZHVsZUNvbmZpZyB7XG4gIG1vZHVsZU5hbWU6IE1vZHVsZU5hbWU7XG4gIGV4cG9ydDogc3RyaW5nO1xuICBhbGxvd1RlbXBsYXRlTGl0ZXJhbD86IHRydWU7XG4gIGVuYWJsZVNjb3BlPzogdHJ1ZTtcbiAgcmZjOTMxU3VwcG9ydD86ICdwb2x5ZmlsbGVkJztcbn1cblxuY29uc3QgSU5MSU5FX1BSRUNPTVBJTEVfTU9EVUxFUzogTW9kdWxlQ29uZmlnW10gPSBbXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnZW1iZXItY2xpLWh0bWxiYXJzJyxcbiAgICBleHBvcnQ6ICdoYnMnLFxuICAgIGFsbG93VGVtcGxhdGVMaXRlcmFsOiB0cnVlLFxuICB9LFxuICB7XG4gICAgbW9kdWxlTmFtZTogJ2VtYmVyLWNsaS1odG1sYmFycy1pbmxpbmUtcHJlY29tcGlsZScsXG4gICAgZXhwb3J0OiAnZGVmYXVsdCcsXG4gICAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnaHRtbGJhcnMtaW5saW5lLXByZWNvbXBpbGUnLFxuICAgIGV4cG9ydDogJ2RlZmF1bHQnLFxuICAgIGFsbG93VGVtcGxhdGVMaXRlcmFsOiB0cnVlLFxuICB9LFxuICB7XG4gICAgbW9kdWxlTmFtZTogJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicsXG4gICAgZXhwb3J0OiAncHJlY29tcGlsZVRlbXBsYXRlJyxcbiAgICBlbmFibGVTY29wZTogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsZXInLFxuICAgIGV4cG9ydDogJ3RlbXBsYXRlJyxcbiAgICBlbmFibGVTY29wZTogdHJ1ZSxcbiAgICByZmM5MzFTdXBwb3J0OiAncG9seWZpbGxlZCcsXG4gIH0sXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnMge1xuICAvLyBUaGUgZW1iZXItdGVtcGxhdGUtY29tcGlsZXIuanMgbW9kdWxlIHRoYXQgc2hpcHMgd2l0aGluIHlvdXIgZW1iZXItc291cmNlXG4gIC8vIHZlcnNpb24uIE1hbmRhdG9yeSB3aGVuIHVzaW5nIHRhcmdldEZvcm1hdDogJ3dpcmUnLlxuICBjb21waWxlcj86IEVtYmVyVGVtcGxhdGVDb21waWxlcjtcblxuICAvLyBBbGxvd3MgeW91IHRvIHJlbWFwIHdoYXQgaW1wb3J0cyB3aWxsIGJlIGVtaXR0ZWQgaW4gb3VyIGNvbXBpbGVkIG91dHB1dC4gQnlcbiAgLy8gZXhhbXBsZTpcbiAgLy9cbiAgLy8gICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IHtcbiAgLy8gICAgICdAZW1iZXIvdGVtcGxhdGUtZmFjdG9yeSc6IHtcbiAgLy8gICAgICAgY3JlYXRlVGVtcGxhdGVGYWN0b3J5OiBbJ2NyZWF0ZVRlbXBsYXRlRmFjdG9yeScsICdAZ2xpbW1lci9jb3JlJ10sXG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvL1xuICAvLyBOb3JtYWwgRW1iZXIgYXBwcyBzaG91bGRuJ3QgbmVlZCB0aGlzLCBpdCBleGlzdHMgdG8gc3VwcG9ydCBvdGhlclxuICAvLyBlbnZpcm9ubWVudHMgbGlrZSBzdGFuZGFsb25lIEdsaW1tZXJKU1xuICBvdXRwdXRNb2R1bGVPdmVycmlkZXM/OiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBbc3RyaW5nLCBzdHJpbmddPj47XG5cbiAgLy8gQnkgZGVmYXVsdCwgdGhpcyBwbHVnaW4gaW1wbGVtZW50cyBvbmx5IEVtYmVyJ3Mgc3RhYmxlIHB1YmxpYyBBUEkgZm9yXG4gIC8vIHRlbXBsYXRlIGNvbXBpbGF0aW9uLCB3aGljaCBpczpcbiAgLy9cbiAgLy8gICAgaW1wb3J0IHsgcHJlY29tcGlsZVRlbXBsYXRlIH0gZnJvbSAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJztcbiAgLy9cbiAgLy8gQnV0IGhpc3RvcmljYWxseSB0aGVyZSBhcmUgc2V2ZXJhbCBvdGhlciBpbXBvcnRhYmxlIHN5bnRheGVzIGluIHdpZGVzcHJlYWRcbiAgLy8gdXNlLCBhbmQgd2UgY2FuIGVuYWJsZSB0aG9zZSB0b28gYnkgaW5jbHVkaW5nIHRoZWlyIG1vZHVsZSBuYW1lcyBpbiB0aGlzXG4gIC8vIGxpc3QuXG4gIGVuYWJsZUxlZ2FjeU1vZHVsZXM/OiBMZWdhY3lNb2R1bGVOYW1lW107XG5cbiAgLy8gQ29udHJvbHMgdGhlIG91dHB1dCBmb3JtYXQuXG4gIC8vXG4gIC8vICBcIndpcmVcIjogVGhlIGRlZmF1bHQuIEluIHRoZSBvdXRwdXQsIHlvdXIgdGVtcGxhdGVzIGFyZSByZWFkeSB0byBleGVjdXRlIGluXG4gIC8vICB0aGUgbW9zdCBwZXJmb3JtYW50IHdheS5cbiAgLy9cbiAgLy8gIFwiaGJzXCI6IEluIHRoZSBvdXRwdXQsIHlvdXIgdGVtcGxhdGVzIHdpbGwgc3RpbGwgYmUgaW4gSEJTIGZvcm1hdC5cbiAgLy8gIEdlbmVyYWxseSB0aGlzIG1lYW5zIHRoZXkgd2lsbCBzdGlsbCBuZWVkIGZ1cnRoZXIgcHJvY2Vzc2luZyBiZWZvcmVcbiAgLy8gIHRoZXkncmUgcmVhZHkgdG8gZXhlY3V0ZS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtb2RlIGlzIHRvIHN1cHBvcnQgdGhpbmdzXG4gIC8vICBsaWtlIGNvZGVtb2RzIGFuZCBwcmUtcHVibGljYXRpb24gdHJhbnNmb3JtYXRpb25zIGluIGxpYnJhcmllcy5cbiAgdGFyZ2V0Rm9ybWF0PzogJ3dpcmUnIHwgJ2hicyc7XG5cbiAgLy8gT3B0aW9uYWwgbGlzdCBvZiBjdXN0b20gdHJhbnNmb3JtcyB0byBhcHBseSB0byB0aGUgaGFuZGxlYmFycyBBU1QgYmVmb3JlXG4gIC8vIGNvbXBpbGF0aW9uLlxuICB0cmFuc2Zvcm1zPzogRXh0ZW5kZWRQbHVnaW5CdWlsZGVyW107XG59XG5cbmludGVyZmFjZSBXaXJlT3B0cyB7XG4gIHRhcmdldEZvcm1hdDogJ3dpcmUnO1xuICBjb21waWxlcjogRW1iZXJUZW1wbGF0ZUNvbXBpbGVyO1xuICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIFtzdHJpbmcsIHN0cmluZ10+PjtcbiAgZW5hYmxlTGVnYWN5TW9kdWxlczogTGVnYWN5TW9kdWxlTmFtZVtdO1xuICB0cmFuc2Zvcm1zOiBFeHRlbmRlZFBsdWdpbkJ1aWxkZXJbXTtcbn1cblxuaW50ZXJmYWNlIEhic09wdHMge1xuICB0YXJnZXRGb3JtYXQ6ICdoYnMnO1xuICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIFtzdHJpbmcsIHN0cmluZ10+PjtcbiAgZW5hYmxlTGVnYWN5TW9kdWxlczogTGVnYWN5TW9kdWxlTmFtZVtdO1xuICB0cmFuc2Zvcm1zOiBFeHRlbmRlZFBsdWdpbkJ1aWxkZXJbXTtcbn1cblxudHlwZSBOb3JtYWxpemVkT3B0cyA9IFdpcmVPcHRzIHwgSGJzT3B0cztcblxuZnVuY3Rpb24gbm9ybWFsaXplT3B0cyhvcHRpb25zOiBPcHRpb25zKTogTm9ybWFsaXplZE9wdHMge1xuICBpZiAoKG9wdGlvbnMudGFyZ2V0Rm9ybWF0ID8/ICd3aXJlJykgPT09ICd3aXJlJykge1xuICAgIGxldCB7IGNvbXBpbGVyIH0gPSBvcHRpb25zO1xuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHdoZW4gdGFyZ2V0Rm9ybWF0PT09XCJ3aXJlXCIgeW91IG11c3Qgc2V0IHRoZSBjb21waWxlciBvciBjb21waWxlclBhdGggb3B0aW9uYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dE1vZHVsZU92ZXJyaWRlczoge30sXG4gICAgICBlbmFibGVMZWdhY3lNb2R1bGVzOiBbXSxcbiAgICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRhcmdldEZvcm1hdDogJ3dpcmUnLFxuICAgICAgY29tcGlsZXIsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiB7fSxcbiAgICAgIGVuYWJsZUxlZ2FjeU1vZHVsZXM6IFtdLFxuICAgICAgdHJhbnNmb3JtczogW10sXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGFyZ2V0Rm9ybWF0OiAnaGJzJyxcbiAgICB9O1xuICB9XG59XG5cbmludGVyZmFjZSBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+IHtcbiAgb3B0czogRW52U3BlY2lmaWNPcHRpb25zO1xuICBub3JtYWxpemVkT3B0czogTm9ybWFsaXplZE9wdHM7XG4gIHV0aWw6IEltcG9ydFV0aWw7XG4gIHRlbXBsYXRlRmFjdG9yeTogeyBtb2R1bGVOYW1lOiBzdHJpbmc7IGV4cG9ydE5hbWU6IHN0cmluZyB9O1xuICBwcm9ncmFtOiBOb2RlUGF0aDx0LlByb2dyYW0+O1xuICBsYXN0SW5zZXJ0ZWRQYXRoOiBOb2RlUGF0aDx0LlN0YXRlbWVudD4gfCB1bmRlZmluZWQ7XG4gIGZpbGVuYW1lOiBzdHJpbmc7XG4gIHJlY3Vyc2lvbkd1YXJkOiBTZXQ8dW5rbm93bj47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUGx1Z2luPEVudlNwZWNpZmljT3B0aW9ucz4obG9hZE9wdGlvbnM6IChvcHRzOiBFbnZTcGVjaWZpY09wdGlvbnMpID0+IE9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGh0bWxiYXJzSW5saW5lUHJlY29tcGlsZShcbiAgICBiYWJlbDogdHlwZW9mIEJhYmVsXG4gICk6IEJhYmVsLlBsdWdpbk9iajxTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+PiB7XG4gICAgbGV0IHQgPSBiYWJlbC50eXBlcztcblxuICAgIGNvbnN0IHBsdWdpbiA9IHtcbiAgICAgIHZpc2l0b3I6IHtcbiAgICAgICAgUHJvZ3JhbToge1xuICAgICAgICAgIGVudGVyKHBhdGg6IE5vZGVQYXRoPHQuUHJvZ3JhbT4sIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gICAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkT3B0cyA9IG5vcm1hbGl6ZU9wdHMobG9hZE9wdGlvbnMoc3RhdGUub3B0cykpO1xuICAgICAgICAgICAgc3RhdGUudGVtcGxhdGVGYWN0b3J5ID0gdGVtcGxhdGVGYWN0b3J5Q29uZmlnKHN0YXRlLm5vcm1hbGl6ZWRPcHRzKTtcbiAgICAgICAgICAgIHN0YXRlLnV0aWwgPSBuZXcgSW1wb3J0VXRpbChiYWJlbCwgcGF0aCk7XG4gICAgICAgICAgICBzdGF0ZS5wcm9ncmFtID0gcGF0aDtcbiAgICAgICAgICAgIHN0YXRlLnJlY3Vyc2lvbkd1YXJkID0gbmV3IFNldCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXhpdChfcGF0aDogTm9kZVBhdGg8dC5Qcm9ncmFtPiwgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5ub3JtYWxpemVkT3B0cy50YXJnZXRGb3JtYXQgPT09ICd3aXJlJykge1xuICAgICAgICAgICAgICBmb3IgKGxldCB7IG1vZHVsZU5hbWUsIGV4cG9ydDogZXhwb3J0TmFtZSB9IG9mIGNvbmZpZ3VyZWRNb2R1bGVzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnV0aWwucmVtb3ZlSW1wb3J0KG1vZHVsZU5hbWUsIGV4cG9ydE5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oXG4gICAgICAgICAgcGF0aDogTm9kZVBhdGg8dC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24+LFxuICAgICAgICAgIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+XG4gICAgICAgICkge1xuICAgICAgICAgIGxldCB0YWdQYXRoID0gcGF0aC5nZXQoJ3RhZycpO1xuXG4gICAgICAgICAgaWYgKCF0YWdQYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBjb25maWcgPSByZWZlcmVuY2VzSW5saW5lQ29tcGlsZXIodGFnUGF0aCwgc3RhdGUpO1xuICAgICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjb25maWcuYWxsb3dUZW1wbGF0ZUxpdGVyYWwpIHtcbiAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgYEF0dGVtcHRlZCB0byB1c2UgXFxgJHt0YWdQYXRoLm5vZGUubmFtZX1cXGAgYXMgYSB0ZW1wbGF0ZSB0YWcsIGJ1dCBpdCBjYW4gb25seSBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIHBhc3NlZCB0byBpdDogJHt0YWdQYXRoLm5vZGUubmFtZX0oJ2NvbnRlbnQgaGVyZScpYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aC5ub2RlLnF1YXNpLmV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAncGxhY2Vob2xkZXJzIGluc2lkZSBhIHRhZ2dlZCB0ZW1wbGF0ZSBzdHJpbmcgYXJlIG5vdCBzdXBwb3J0ZWQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IHBhdGgubm9kZS5xdWFzaS5xdWFzaXMubWFwKChxdWFzaSkgPT4gcXVhc2kudmFsdWUuY29va2VkKS5qb2luKCcnKTtcbiAgICAgICAgICBpZiAoc3RhdGUubm9ybWFsaXplZE9wdHMudGFyZ2V0Rm9ybWF0ID09PSAnd2lyZScpIHtcbiAgICAgICAgICAgIGluc2VydENvbXBpbGVkVGVtcGxhdGUoXG4gICAgICAgICAgICAgIGJhYmVsLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgc3RhdGUubm9ybWFsaXplZE9wdHMsXG4gICAgICAgICAgICAgIHRlbXBsYXRlLFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydFRyYW5zZm9ybWVkVGVtcGxhdGUoYmFiZWwsIHN0YXRlLCB0ZW1wbGF0ZSwgcGF0aCwge30sIGNvbmZpZywgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2FsbEV4cHJlc3Npb24ocGF0aDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4sIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gICAgICAgICAgbGV0IGNhbGxlZVBhdGggPSBwYXRoLmdldCgnY2FsbGVlJyk7XG5cbiAgICAgICAgICBpZiAoIWNhbGxlZVBhdGguaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHJlZmVyZW5jZXNJbmxpbmVDb21waWxlcihjYWxsZWVQYXRoLCBzdGF0ZSk7XG4gICAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVjdXJzaW9uR3VhcmQuaGFzKHBhdGgubm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aC5nZXQoJ2FyZ3VtZW50cycpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgYCR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IGNhbiBvbmx5IGJlIGludm9rZWQgd2l0aCAyIGFyZ3VtZW50czogdGhlIHRlbXBsYXRlIHN0cmluZyBhbmQgYW55IHN0YXRpYyBvcHRpb25zYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgW2ZpcnN0QXJnLCBzZWNvbmRBcmddID0gcGF0aC5nZXQoJ2FyZ3VtZW50cycpO1xuXG4gICAgICAgICAgbGV0IHRlbXBsYXRlO1xuXG4gICAgICAgICAgc3dpdGNoIChmaXJzdEFyZz8ubm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzpcbiAgICAgICAgICAgICAgdGVtcGxhdGUgPSBmaXJzdEFyZy5ub2RlLnZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RlbXBsYXRlTGl0ZXJhbCc6XG4gICAgICAgICAgICAgIGlmIChmaXJzdEFyZy5ub2RlLmV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICAgICdwbGFjZWhvbGRlcnMgaW5zaWRlIGEgdGVtcGxhdGUgc3RyaW5nIGFyZSBub3Qgc3VwcG9ydGVkJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBmaXJzdEFyZy5ub2RlLnF1YXNpcy5tYXAoKHF1YXNpKSA9PiBxdWFzaS52YWx1ZS5jb29rZWQpLmpvaW4oJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgIGB0YWdnZWQgdGVtcGxhdGUgc3RyaW5ncyBpbnNpZGUgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gYXJlIG5vdCBzdXBwb3J0ZWRgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYCR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IHNob3VsZCBiZSBpbnZva2VkIHdpdGggYXQgbGVhc3QgYSBzaW5nbGUgYXJndW1lbnQgKHRoZSB0ZW1wbGF0ZSBzdHJpbmcpYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgICBsZXQgYmFja2luZ0NsYXNzOiB1bmRlZmluZWQgfCBOb2RlUGF0aDxQYXJhbWV0ZXJzPHR5cGVvZiB0LmNhbGxFeHByZXNzaW9uPlsxXVtudW1iZXJdPjtcblxuICAgICAgICAgIGlmICghc2Vjb25kQXJnKSB7XG4gICAgICAgICAgICB1c2VyVHlwZWRPcHRpb25zID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc2Vjb25kQXJnLmlzT2JqZWN0RXhwcmVzc2lvbigpKSB7XG4gICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gY2FuIG9ubHkgYmUgaW52b2tlZCB3aXRoIDIgYXJndW1lbnRzOiB0aGUgdGVtcGxhdGUgc3RyaW5nLCBhbmQgYW55IHN0YXRpYyBvcHRpb25zYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1c2VyVHlwZWRPcHRpb25zID0gbmV3IEV4cHJlc3Npb25QYXJzZXIoYmFiZWwpLnBhcnNlT2JqZWN0RXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgY2FsbGVlUGF0aC5ub2RlLm5hbWUsXG4gICAgICAgICAgICAgIHNlY29uZEFyZyxcbiAgICAgICAgICAgICAgY29uZmlnLmVuYWJsZVNjb3BlLFxuICAgICAgICAgICAgICBCb29sZWFuKGNvbmZpZy5yZmM5MzFTdXBwb3J0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjb25maWcucmZjOTMxU3VwcG9ydCAmJiB1c2VyVHlwZWRPcHRpb25zLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICBiYWNraW5nQ2xhc3MgPSB1c2VyVHlwZWRPcHRpb25zLmNvbXBvbmVudCBhcyBOb2RlUGF0aDxcbiAgICAgICAgICAgICAgICBQYXJhbWV0ZXJzPHR5cGVvZiB0LmNhbGxFeHByZXNzaW9uPlsxXVtudW1iZXJdXG4gICAgICAgICAgICAgID47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm5vcm1hbGl6ZWRPcHRzLnRhcmdldEZvcm1hdCA9PT0gJ3dpcmUnKSB7XG4gICAgICAgICAgICBpbnNlcnRDb21waWxlZFRlbXBsYXRlKFxuICAgICAgICAgICAgICBiYWJlbCxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRPcHRzLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyxcbiAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICBiYWNraW5nQ2xhc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydFRyYW5zZm9ybWVkVGVtcGxhdGUoXG4gICAgICAgICAgICAgIGJhYmVsLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMsXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgYmFja2luZ0NsYXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBwcmUodGhpczogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPiwgZmlsZSkge1xuICAgICAgICAvLyBydW4gb3VyIHByb2Nlc3NpbmcgaW4gcHJlIHNvIHRoYXQgaW1wb3J0cyBmb3IgZ3RzXG4gICAgICAgIC8vIGFyZSBrZXB0IGZvciBvdGhlciBwbHVnaW5zLlxuICAgICAgICBiYWJlbC50cmF2ZXJzZShmaWxlLmFzdCwgcGx1Z2luLnZpc2l0b3IsIGZpbGUuc2NvcGUsIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0b3I6IHt9LFxuICAgIH07XG4gIH0gYXMgKGJhYmVsOiB0eXBlb2YgQmFiZWwpID0+IEJhYmVsLlBsdWdpbk9iajx1bmtub3duPjtcbn1cblxuZnVuY3Rpb24qIGNvbmZpZ3VyZWRNb2R1bGVzPEVudlNwZWNpZmljT3B0aW9ucz4oc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgZm9yIChsZXQgbW9kdWxlQ29uZmlnIG9mIElOTElORV9QUkVDT01QSUxFX01PRFVMRVMpIHtcbiAgICBpZiAoXG4gICAgICBtb2R1bGVDb25maWcubW9kdWxlTmFtZSAhPT0gJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicgJiZcbiAgICAgIG1vZHVsZUNvbmZpZy5tb2R1bGVOYW1lICE9PSAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGVyJyAmJlxuICAgICAgIXN0YXRlLm5vcm1hbGl6ZWRPcHRzLmVuYWJsZUxlZ2FjeU1vZHVsZXMuaW5jbHVkZXMobW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUpXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgeWllbGQgbW9kdWxlQ29uZmlnO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZmVyZW5jZXNJbmxpbmVDb21waWxlcjxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBwYXRoOiBOb2RlUGF0aDx0LklkZW50aWZpZXI+LFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPlxuKTogTW9kdWxlQ29uZmlnIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChsZXQgbW9kdWxlQ29uZmlnIG9mIGNvbmZpZ3VyZWRNb2R1bGVzKHN0YXRlKSkge1xuICAgIGlmIChwYXRoLnJlZmVyZW5jZXNJbXBvcnQobW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUsIG1vZHVsZUNvbmZpZy5leHBvcnQpKSB7XG4gICAgICByZXR1cm4gbW9kdWxlQ29uZmlnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBydW50aW1lRXJyb3JJSUZFKGJhYmVsOiB0eXBlb2YgQmFiZWwsIHJlcGxhY2VtZW50czogeyBFUlJPUl9NRVNTQUdFOiBzdHJpbmcgfSkge1xuICBsZXQgc3RhdGVtZW50ID0gYmFiZWwudGVtcGxhdGUoYChmdW5jdGlvbigpIHtcXG4gIHRocm93IG5ldyBFcnJvcignRVJST1JfTUVTU0FHRScpO1xcbn0pKCk7YCkoXG4gICAgcmVwbGFjZW1lbnRzXG4gICkgYXMgdC5FeHByZXNzaW9uU3RhdGVtZW50O1xuICByZXR1cm4gc3RhdGVtZW50LmV4cHJlc3Npb247XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2NvcGVMb2NhbHMoXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBmb3JtYXRPcHRpb25zOiBNb2R1bGVDb25maWcsXG4gIHRhcmdldDogTm9kZVBhdGg8dC5FeHByZXNzaW9uPlxuKTogU2NvcGVMb2NhbHMge1xuICBpZiAoZm9ybWF0T3B0aW9ucy5yZmM5MzFTdXBwb3J0ICYmIHVzZXJUeXBlZE9wdGlvbnMuZXZhbCkge1xuICAgIHJldHVybiBuZXcgU2NvcGVMb2NhbHMoeyBtb2RlOiAnaW1wbGljaXQnLCBqc1BhdGg6IHRhcmdldCB9KTtcbiAgfSBlbHNlIGlmICh1c2VyVHlwZWRPcHRpb25zLnNjb3BlKSB7XG4gICAgcmV0dXJuIHVzZXJUeXBlZE9wdGlvbnMuc2NvcGUgYXMgU2NvcGVMb2NhbHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBTY29wZUxvY2Fscyh7IG1vZGU6ICdleHBsaWNpdCcgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRQcmVjb21waWxlT3B0aW9uczxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBiYWJlbDogdHlwZW9mIEJhYmVsLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbj4sXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgY29uZmlnOiBNb2R1bGVDb25maWcsXG4gIHNjb3BlOiBTY29wZUxvY2Fsc1xuKTogUHJlcHJvY2Vzc09wdGlvbnMgJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIGxldCBqc3V0aWxzID0gbmV3IEpTVXRpbHMoYmFiZWwsIHN0YXRlLCB0YXJnZXQsIHNjb3BlLmFkZC5iaW5kKHNjb3BlKSwgc3RhdGUudXRpbCk7XG4gIGxldCBtZXRhID0gT2JqZWN0LmFzc2lnbih7IGpzdXRpbHMgfSwgdXNlclR5cGVkT3B0aW9ucz8ubWV0YSk7XG5cbiAgbGV0IG91dHB1dDogUHJlcHJvY2Vzc09wdGlvbnMgJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHtcbiAgICBjb250ZW50czogdGVtcGxhdGUsXG5cbiAgICAvLyB3ZSd2ZSBleHRlbmRlZCBtZXRhIHRvIGFkZCBqc3V0aWxzLCBidXQgdGhlIHR5cGVzIGluIEBnbGltbWVyL3N5bnRheFxuICAgIC8vIGRvbid0IGFjY291bnQgZm9yIGV4dGVuc2lvblxuICAgIG1ldGE6IG1ldGEgYXMgUHJlcHJvY2Vzc09wdGlvbnNbJ21ldGEnXSxcblxuICAgIC8vIFRPRE86IGVtYnJvaWRlcidzIHRlbXBsYXRlLWNvbXBpbGVyIGFsbG93cyB0aGlzIHRvIGJlIG92ZXJyaWRlbiB0byBnZXRcbiAgICAvLyBiYWNrd2FyZC1jb21wYXRpYmxlIG1vZHVsZSBuYW1lcyB0aGF0IGRvbid0IG1hdGNoIHRoZSByZWFsIG5hbWUgb2YgdGhlXG4gICAgLy8gb24tZGlzayBmaWxlLiBXaGF0J3Mgb3VyIHBsYW4gZm9yIG1pZ3JhdGluZyBwZW9wbGUgYXdheSBmcm9tIHRoYXQ/XG4gICAgbW9kdWxlTmFtZTogc3RhdGUuZmlsZW5hbWUsXG5cbiAgICAvLyBUaGlzIGlzIGhlcmUgc28gaXQncyAqYWx3YXlzKiB0aGUgcmVhbCBmaWxlbmFtZS4gSGlzdG9yaWNhbGx5LCB0aGVyZSBpc1xuICAgIC8vIGFsc28gYG1vZHVsZU5hbWVgIGJ1dCB0aGF0IGRpZCBub3QgbWF0Y2ggdGhlIHJlYWwgb24tZGlzayBmaWxlbmFtZSwgaXRcbiAgICAvLyB3YXMgdGhlIG5vdGlvbmFsIHJ1bnRpbWUgbW9kdWxlIG5hbWUgZnJvbSBjbGFzc2ljIGVtYmVyIGJ1aWxkcy5cbiAgICBmaWxlbmFtZTogc3RhdGUuZmlsZW5hbWUsXG5cbiAgICBwbHVnaW5zOiB7XG4gICAgICAvLyB0aGUgY2FzdCBpcyBuZWVkZWQgaGVyZSBvbmx5IGJlY2F1c2Ugb3VyIG1ldGEgaXMgZXh0ZW5kZWQuIFRoYXQgaXMsXG4gICAgICAvLyB0aGVzZSBwbHVnaW5zIGNhbiBhY2Nlc3MgbWV0YS5qc3V0aWxzLlxuICAgICAgYXN0OiBbLi4uc3RhdGUubm9ybWFsaXplZE9wdHMudHJhbnNmb3Jtcywgc2NvcGUuY3Jhd2woKV0gYXMgQVNUUGx1Z2luQnVpbGRlcltdLFxuICAgIH0sXG4gIH07XG5cbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVzZXJUeXBlZE9wdGlvbnMpKSB7XG4gICAgaWYgKGtleSAhPT0gJ3Njb3BlJykge1xuICAgICAgLy8gYHNjb3BlYCBpbiB0aGUgdXNlci1mYWNpbmcgQVBJIGJlY29tZXMgYGxvY2Fsc2AgaW4gdGhlIGxvdy1sZXZlbFxuICAgICAgLy8gZW1iZXItdGVtcGxhdGUtY29tcGlsZXIgQVBJXG4gICAgICBvdXRwdXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIG91dHB1dC5sb2NhbHMgPSBzY29wZS5sb2NhbHM7XG5cbiAgaWYgKGNvbmZpZy5yZmM5MzFTdXBwb3J0KSB7XG4gICAgb3V0cHV0LnN0cmljdE1vZGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gcmVtYXBBbmRCaW5kSWRlbnRpZmllcnModGFyZ2V0OiBOb2RlUGF0aCwgYmFiZWw6IHR5cGVvZiBCYWJlbCwgc2NvcGVMb2NhbHM6IFNjb3BlTG9jYWxzKSB7XG4gIHRhcmdldC50cmF2ZXJzZSh7XG4gICAgSWRlbnRpZmllcihwYXRoOiBOb2RlUGF0aDx0LklkZW50aWZpZXI+KSB7XG4gICAgICBpZiAoc2NvcGVMb2NhbHMuaGFzKHBhdGgubm9kZS5uYW1lKSAmJiBwYXRoLm5vZGUubmFtZSAhPT0gc2NvcGVMb2NhbHMuZ2V0KHBhdGgubm9kZS5uYW1lKSkge1xuICAgICAgICAvLyB0aGlzIGlkZW50aWZpZXIgaGFzIGRpZmZlcmVudCBuYW1lcyBpbiBoYnMgdnMganMsIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgaGJzIG5hbWUgaW4gdGhlIHRlbXBsYXRlIGNvbXBpbGVyIG91dHB1dCB3aXRoIHRoZSBqc1xuICAgICAgICAvLyBuYW1lXG4gICAgICAgIHBhdGgucmVwbGFjZVdpdGgoYmFiZWwudHlwZXMuaWRlbnRpZmllcihzY29wZUxvY2Fscy5nZXQocGF0aC5ub2RlLm5hbWUpKSk7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGlzIHdoZXJlIHdlIHRlbGwgYmFiZWwncyBzY29wZSBzeXN0ZW0gYWJvdXQgdGhlIG5ldyByZWZlcmVuY2Ugd2VcbiAgICAgIC8vIGp1c3QgaW50cm9kdWNlZC4gQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tdHlwZXNjcmlwdCBpbiBwYXJ0aWN1bGFyXG4gICAgICAvLyBjYXJlcyBhIGxvdCBhYm91dCB0aG9zZSByZWZlcmVuY2VzIGJlaW5nIHByZXNlbnQuXG4gICAgICBwYXRoLnNjb3BlLmdldEJpbmRpbmcocGF0aC5ub2RlLm5hbWUpPy5yZWZlcmVuY2UocGF0aCk7XG4gICAgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydENvbXBpbGVkVGVtcGxhdGU8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIG9wdHM6IFdpcmVPcHRzLFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbj4sXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb25maWc6IE1vZHVsZUNvbmZpZyxcbiAgYmFja2luZ0NsYXNzOiBOb2RlUGF0aDxQYXJhbWV0ZXJzPHR5cGVvZiB0LmNhbGxFeHByZXNzaW9uPlsxXVtudW1iZXJdPiB8IHVuZGVmaW5lZFxuKSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG4gIGxldCBzY29wZUxvY2FscyA9IGJ1aWxkU2NvcGVMb2NhbHModXNlclR5cGVkT3B0aW9ucywgY29uZmlnLCB0YXJnZXQpO1xuICBsZXQgb3B0aW9ucyA9IGJ1aWxkUHJlY29tcGlsZU9wdGlvbnMoXG4gICAgYmFiZWwsXG4gICAgdGFyZ2V0LFxuICAgIHN0YXRlLFxuICAgIHRlbXBsYXRlLFxuICAgIHVzZXJUeXBlZE9wdGlvbnMsXG4gICAgY29uZmlnLFxuICAgIHNjb3BlTG9jYWxzXG4gICk7XG5cbiAgbGV0IHByZWNvbXBpbGVSZXN1bHRTdHJpbmc6IHN0cmluZztcblxuICAvLyBpbnNlcnRSdW50aW1lRXJyb3JzIGlzIGxlZ2FjeSBhbmQgbm90IHN1cHBvcnRlZCBieSB0aGUgbmV3ZXIgcmZjOTMxIGZvcm1cbiAgaWYgKG9wdGlvbnMuaW5zZXJ0UnVudGltZUVycm9ycyAmJiAhY29uZmlnLnJmYzkzMVN1cHBvcnQpIHtcbiAgICB0cnkge1xuICAgICAgcHJlY29tcGlsZVJlc3VsdFN0cmluZyA9IG9wdHMuY29tcGlsZXIucHJlY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRhcmdldC5yZXBsYWNlV2l0aChydW50aW1lRXJyb3JJSUZFKGJhYmVsLCB7IEVSUk9SX01FU1NBR0U6IChlcnJvciBhcyBhbnkpLm1lc3NhZ2UgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcmVjb21waWxlUmVzdWx0U3RyaW5nID0gb3B0cy5jb21waWxlci5wcmVjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGxldCB0ZW1wbGF0ZUV4cHJlc3Npb24gPSBiYWJlbC50ZW1wbGF0ZS5leHByZXNzaW9uLmFzdChwcmVjb21waWxlUmVzdWx0U3RyaW5nKTtcblxuICB0LmFkZENvbW1lbnQoXG4gICAgdGVtcGxhdGVFeHByZXNzaW9uLFxuICAgICdsZWFkaW5nJyxcbiAgICBgXFxuICAke3RlbXBsYXRlLnJlcGxhY2UoL1xcKlxcLy9nLCAnKlxcXFwvJyl9XFxuYCxcbiAgICAvKiBsaW5lIGNvbW1lbnQ/ICovIGZhbHNlXG4gICk7XG5cbiAgc3RhdGUudXRpbC5yZXBsYWNlV2l0aCh0YXJnZXQsIChpKSA9PiB7XG4gICAgbGV0IHRlbXBsYXRlRmFjdG9yeUlkZW50aWZpZXIgPSBpLmltcG9ydChcbiAgICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeS5tb2R1bGVOYW1lLFxuICAgICAgc3RhdGUudGVtcGxhdGVGYWN0b3J5LmV4cG9ydE5hbWVcbiAgICApO1xuXG4gICAgbGV0IGV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKHRlbXBsYXRlRmFjdG9yeUlkZW50aWZpZXIsIFt0ZW1wbGF0ZUV4cHJlc3Npb25dKTtcblxuICAgIGlmIChjb25maWcucmZjOTMxU3VwcG9ydCkge1xuICAgICAgZXhwcmVzc2lvbiA9IHQuY2FsbEV4cHJlc3Npb24oaS5pbXBvcnQoJ0BlbWJlci9jb21wb25lbnQnLCAnc2V0Q29tcG9uZW50VGVtcGxhdGUnKSwgW1xuICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICBiYWNraW5nQ2xhc3M/Lm5vZGUgPz9cbiAgICAgICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgaS5pbXBvcnQoJ0BlbWJlci9jb21wb25lbnQvdGVtcGxhdGUtb25seScsICdkZWZhdWx0JywgJ3RlbXBsYXRlT25seScpLFxuICAgICAgICAgICAgW11cbiAgICAgICAgICApLFxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9KTtcblxuICByZW1hcEFuZEJpbmRJZGVudGlmaWVycyh0YXJnZXQsIGJhYmVsLCBzY29wZUxvY2Fscyk7XG59XG5cbmZ1bmN0aW9uIGluc2VydFRyYW5zZm9ybWVkVGVtcGxhdGU8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIHRlbXBsYXRlOiBzdHJpbmcsXG4gIHRhcmdldDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4gfCBOb2RlUGF0aDx0LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbj4sXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBmb3JtYXRPcHRpb25zOiBNb2R1bGVDb25maWcsXG4gIGJhY2tpbmdDbGFzczogTm9kZVBhdGg8UGFyYW1ldGVyczx0eXBlb2YgdC5jYWxsRXhwcmVzc2lvbj5bMV1bbnVtYmVyXT4gfCB1bmRlZmluZWRcbikge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2NvcGVMb2NhbHMgPSBidWlsZFNjb3BlTG9jYWxzKHVzZXJUeXBlZE9wdGlvbnMsIGZvcm1hdE9wdGlvbnMsIHRhcmdldCk7XG4gIGxldCBvcHRpb25zID0gYnVpbGRQcmVjb21waWxlT3B0aW9ucyhcbiAgICBiYWJlbCxcbiAgICB0YXJnZXQsXG4gICAgc3RhdGUsXG4gICAgdGVtcGxhdGUsXG4gICAgdXNlclR5cGVkT3B0aW9ucyxcbiAgICBmb3JtYXRPcHRpb25zLFxuICAgIHNjb3BlTG9jYWxzXG4gICk7XG4gIGxldCBhc3QgPSBwcmVwcm9jZXNzKHRlbXBsYXRlLCB7IC4uLm9wdGlvbnMsIG1vZGU6ICdjb2RlbW9kJyB9KTtcbiAgbGV0IHRyYW5zZm9ybWVkID0gcHJpbnQoYXN0LCB7IGVudGl0eUVuY29kaW5nOiAncmF3JyB9KTtcblxuICBpZiAodGFyZ2V0LmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgIHVwZGF0ZUNhbGxGb3JtPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gICAgICB0YXJnZXQsXG4gICAgICB0cmFuc2Zvcm1lZCxcbiAgICAgIGZvcm1hdE9wdGlvbnMsXG4gICAgICBzY29wZUxvY2FscyxcbiAgICAgIHN0YXRlLFxuICAgICAgYmFiZWwsXG4gICAgICBiYWNraW5nQ2xhc3NcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUJhY2t0aWNrRm9ybTxFbnZTcGVjaWZpY09wdGlvbnM+KHNjb3BlTG9jYWxzLCBzdGF0ZSwgdGFyZ2V0LCB0LCB0cmFuc2Zvcm1lZCwgYmFiZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUJhY2t0aWNrRm9ybTxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBzY29wZUxvY2FsczogU2NvcGVMb2NhbHMsXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uPixcbiAgdDogdHlwZW9mIEJhYmVsLnR5cGVzLFxuICB0cmFuc2Zvcm1lZDogc3RyaW5nLFxuICBiYWJlbDogdHlwZW9mIEJhYmVsXG4pIHtcbiAgaWYgKHNjb3BlTG9jYWxzLmlzRW1wdHkoKSkge1xuICAgIC8vIHNpbXBsZSBjYXNlOiBqdXN0IHJlcGxhY2UgdGhlIHN0cmluZyBsaXRlcmFsIHBhcnQgd2l0aCB0aGUgdHJhbnNmb3JtZWRcbiAgICAvLyB0ZW1wbGF0ZSBjb250ZW50c1xuICAgICh0YXJnZXQuZ2V0KCdxdWFzaScpLmdldCgncXVhc2lzLjAnKSBhcyBOb2RlUGF0aDx0LlRlbXBsYXRlRWxlbWVudD4pLnJlcGxhY2VXaXRoKFxuICAgICAgdC50ZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHRyYW5zZm9ybWVkIH0pXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBuZWVkIHRvIGFkZCBzY29wZSwgc28gbmVlZCB0byByZXBsYWNlIHRoZSBiYWNrdGlja3MgZm9ybSB3aXRoIGEgY2FsbFxuICAvLyBleHByZXNzaW9uIHRvIHByZWNvbXBpbGVUZW1wbGF0ZVxuICBtYXliZVBydW5lSW1wb3J0KHN0YXRlLnV0aWwsIHRhcmdldC5nZXQoJ3RhZycpKTtcbiAgbGV0IG5ld0NhbGwgPSBzdGF0ZS51dGlsLnJlcGxhY2VXaXRoKHRhcmdldCwgKGkpID0+XG4gICAgdC5jYWxsRXhwcmVzc2lvbihwcmVjb21waWxlVGVtcGxhdGUoaSksIFt0LnN0cmluZ0xpdGVyYWwodHJhbnNmb3JtZWQpXSlcbiAgKTtcbiAgdXBkYXRlU2NvcGUoYmFiZWwsIG5ld0NhbGwsIHNjb3BlTG9jYWxzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2FsbEZvcm08RW52U3BlY2lmaWNPcHRpb25zPihcbiAgdGFyZ2V0OiBOb2RlUGF0aDxCYWJlbC50eXBlcy5DYWxsRXhwcmVzc2lvbj4sXG4gIHRyYW5zZm9ybWVkOiBzdHJpbmcsXG4gIGZvcm1hdE9wdGlvbnM6IE1vZHVsZUNvbmZpZyxcbiAgc2NvcGVMb2NhbHM6IFNjb3BlTG9jYWxzLFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPixcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgYmFja2luZ0NsYXNzOlxuICAgIHwgTm9kZVBhdGg8QmFiZWwudHlwZXMuRXhwcmVzc2lvbiB8IEJhYmVsLnR5cGVzLkFyZ3VtZW50UGxhY2Vob2xkZXIgfCBCYWJlbC50eXBlcy5TcHJlYWRFbGVtZW50PlxuICAgIHwgdW5kZWZpbmVkXG4pIHtcbiAgLy8gZmlyc3QgdGhlIHNpbXBsZSBwYXJ0OiByZXBsYWNpbmcgdGhlIHN0cmluZyBsaXRlcmFsIHdpdGggdGhlIGFjdHVhbCBib2R5IG9mXG4gIC8vIHRoZSByZXdyaXR0ZW4gdGVtcGxhdGVcbiAgKHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4wJykgYXMgTm9kZVBhdGg8dC5Ob2RlPikucmVwbGFjZVdpdGgoXG4gICAgYmFiZWwudHlwZXMuc3RyaW5nTGl0ZXJhbCh0cmFuc2Zvcm1lZClcbiAgKTtcblxuICBpZiAoIWZvcm1hdE9wdGlvbnMuZW5hYmxlU2NvcGUgJiYgIXNjb3BlTG9jYWxzLmlzRW1wdHkoKSkge1xuICAgIC8vIGFuIEFTVCB0cmFuc2Zvcm0gYWRkZWQgbGV4aWNhbGx5IHNjb3BlZCB2YWx1ZXMgdG8gYSB0ZW1wbGF0ZSB0aGF0XG4gICAgLy8gd2Fzbid0IGFscmVhZHkgaW4gYSBmb3JtIHRoYXQgc3VwcG9ydHMgdGhlbSwgc28gY29udmVydCBmb3JtLlxuICAgIG1heWJlUHJ1bmVJbXBvcnQoc3RhdGUudXRpbCwgdGFyZ2V0LmdldCgnY2FsbGVlJykpO1xuICAgIHN0YXRlLnV0aWwucmVwbGFjZVdpdGgodGFyZ2V0LmdldCgnY2FsbGVlJyksIChpKSA9PiBwcmVjb21waWxlVGVtcGxhdGUoaSkpO1xuICB9XG5cbiAgaWYgKGZvcm1hdE9wdGlvbnMucmZjOTMxU3VwcG9ydCA9PT0gJ3BvbHlmaWxsZWQnKSB7XG4gICAgbWF5YmVQcnVuZUltcG9ydChzdGF0ZS51dGlsLCB0YXJnZXQuZ2V0KCdjYWxsZWUnKSk7XG4gICAgc3RhdGUudXRpbC5yZXBsYWNlV2l0aCh0YXJnZXQuZ2V0KCdjYWxsZWUnKSwgKGkpID0+IHByZWNvbXBpbGVUZW1wbGF0ZShpKSk7XG4gICAgY29udmVydFN0cmljdE1vZGUoYmFiZWwsIHRhcmdldCk7XG4gICAgcmVtb3ZlRXZhbEFuZFNjb3BlKHRhcmdldCk7XG4gICAgdGFyZ2V0Lm5vZGUuYXJndW1lbnRzID0gdGFyZ2V0Lm5vZGUuYXJndW1lbnRzLnNsaWNlKDAsIDIpO1xuICAgIHN0YXRlLnJlY3Vyc2lvbkd1YXJkLmFkZCh0YXJnZXQubm9kZSk7XG4gICAgc3RhdGUudXRpbC5yZXBsYWNlV2l0aCh0YXJnZXQsIChpKSA9PlxuICAgICAgYmFiZWwudHlwZXMuY2FsbEV4cHJlc3Npb24oaS5pbXBvcnQoJ0BlbWJlci9jb21wb25lbnQnLCAnc2V0Q29tcG9uZW50VGVtcGxhdGUnKSwgW1xuICAgICAgICB0YXJnZXQubm9kZSxcbiAgICAgICAgYmFja2luZ0NsYXNzPy5ub2RlID8/XG4gICAgICAgICAgYmFiZWwudHlwZXMuY2FsbEV4cHJlc3Npb24oXG4gICAgICAgICAgICBpLmltcG9ydCgnQGVtYmVyL2NvbXBvbmVudC90ZW1wbGF0ZS1vbmx5JywgJ2RlZmF1bHQnLCAndGVtcGxhdGVPbmx5JyksXG4gICAgICAgICAgICBbXVxuICAgICAgICAgICksXG4gICAgICBdKVxuICAgICk7XG4gICAgLy8gd2UganVzdCB3cmFwcGVkIHRoZSB0YXJnZXQgY2FsbEV4cHJlc3Npb24gaW4gdGhlIGNhbGwgdG9cbiAgICAvLyBzZXRDb21wb25lbnRUZW1wbGF0ZS4gQWRqdXN0IGB0YXJnZXRgIGJhY2sgdG8gcG9pbnQgYXQgdGhlXG4gICAgLy8gcHJlY29tcGlsZVRlbXBsYXRlIGNhbGwgZm9yIHRoZSBmaW5hbCB1cGRhdGVTY29wZSBiZWxvdy5cbiAgICAvL1xuICAgIHRhcmdldCA9IHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4wJykgYXMgTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj47XG4gIH1cbiAgLy8gV2UgZGVsaWJlcmF0ZWx5IGRvIHVwZGF0ZVNjb3BlIGF0IHRoZSBlbmQgc28gdGhhdCB3aGVuIGl0IHVwZGF0ZXNcbiAgLy8gcmVmZXJlbmNlcywgdGhvc2UgcmVmZXJlbmNlcyB3aWxsIHBvaW50IHRvIHRoZSBhY2N1cmF0ZSBwYXRocyBpbiB0aGVcbiAgLy8gZmluYWwgQVNULlxuICB1cGRhdGVTY29wZShiYWJlbCwgdGFyZ2V0LCBzY29wZUxvY2Fscyk7XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlRmFjdG9yeUNvbmZpZyhvcHRzOiBOb3JtYWxpemVkT3B0cykge1xuICBsZXQgbW9kdWxlTmFtZSA9ICdAZW1iZXIvdGVtcGxhdGUtZmFjdG9yeSc7XG4gIGxldCBleHBvcnROYW1lID0gJ2NyZWF0ZVRlbXBsYXRlRmFjdG9yeSc7XG4gIGxldCBvdmVycmlkZXMgPSBvcHRzLm91dHB1dE1vZHVsZU92ZXJyaWRlc1ttb2R1bGVOYW1lXT8uW2V4cG9ydE5hbWVdO1xuICByZXR1cm4gb3ZlcnJpZGVzXG4gICAgPyB7IGV4cG9ydE5hbWU6IG92ZXJyaWRlc1swXSwgbW9kdWxlTmFtZTogb3ZlcnJpZGVzWzFdIH1cbiAgICA6IHsgZXhwb3J0TmFtZSwgbW9kdWxlTmFtZSB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFNjb3BlKGJhYmVsOiB0eXBlb2YgQmFiZWwsIGxvY2FsczogU2NvcGVMb2NhbHMpIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcblxuICByZXR1cm4gdC5hcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihcbiAgICBbXSxcbiAgICB0Lm9iamVjdEV4cHJlc3Npb24oXG4gICAgICBsb2NhbHNcbiAgICAgICAgLmVudHJpZXMoKVxuICAgICAgICAubWFwKChbbmFtZSwgaWRlbnRpZmllcl0pID0+XG4gICAgICAgICAgdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIobmFtZSksIHQuaWRlbnRpZmllcihpZGVudGlmaWVyKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIClcbiAgICApXG4gICk7XG59XG5cbi8vIHRoaXMgaXMgcmVzcG9uc2libGUgYm90aCBmb3IgYWRqdXN0aW5nIHRoZSBBU1QgZm9yIG91ciBzY29wZSBhcmd1bWVudCAqYW5kKlxuLy8gZW5zdXJpbmcgdGhhdCBiYWJlbCdzIHNjb3BlIHN5c3RlbSB3aWxsIHNlZSB0aGF0IHRoZXNlIG5ldyBpZGVudGlmaWVyc1xuLy8gcmVmZXJlbmNlIHRoZWlyIGJpbmRpbmdzLiBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS10eXBlc2NyaXB0IGluIHBhcnRpY3VsYXJcbi8vIGNhcmVzIGFuIGF3ZnVsIGxvdCBhYm91dCB3aGV0aGVyIGFuIGltcG9ydCBoYXMgdmFsaWQgbm9uLXR5cGUgcmVmZXJlbmNlcywgc29cbi8vIHRoZXNlIG5ld2x5IGludHJvZHVjZCByZWZlcmVuY2VzIG5lZWQgdG8gYmUgdmFsaWQuXG5mdW5jdGlvbiB1cGRhdGVTY29wZShiYWJlbDogdHlwZW9mIEJhYmVsLCB0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+LCBsb2NhbHM6IFNjb3BlTG9jYWxzKSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG4gIGxldCBzZWNvbmRBcmcgPSB0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMScpIGFzIE5vZGVQYXRoPHQuT2JqZWN0RXhwcmVzc2lvbj4gfCB1bmRlZmluZWQ7XG4gIGlmIChzZWNvbmRBcmcpIHtcbiAgICBsZXQgc2NvcGUgPSBzZWNvbmRBcmcuZ2V0KCdwcm9wZXJ0aWVzJykuZmluZCgocCkgPT4ge1xuICAgICAgbGV0IGtleSA9IHAuZ2V0KCdrZXknKSBhcyBOb2RlUGF0aDx0Lk5vZGU+O1xuICAgICAgcmV0dXJuIGtleS5pc0lkZW50aWZpZXIoKSAmJiBrZXkubm9kZS5uYW1lID09PSAnc2NvcGUnO1xuICAgIH0pO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgaWYgKGxvY2Fscy5pc0VtcHR5KCkpIHtcbiAgICAgICAgc2NvcGUucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZS5zZXQoJ3ZhbHVlJywgYnVpbGRTY29wZShiYWJlbCwgbG9jYWxzKSk7XG4gICAgICAgIC8vIGZ1bm55LWxvb2tpbmcgbmFtaW5nIGhlcmUsIGJ1dCBpdCBhY3R1YWxseSBtYWtlcyBzZW5zZSBiZWNhdXNlIHdlJ3JlXG4gICAgICAgIC8vIGNvbm5lY3RpbmcgdGhlIGdsaW1tZXIgc2NvcGUgc3lzdGVtIHdpdGggdGhlIGJhYmVsIHNjb3BlIHN5c3RlbS5cbiAgICAgICAgc2NvcGUuc2NvcGUuY3Jhd2woKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFsb2NhbHMuaXNFbXB0eSgpKSB7XG4gICAgICBzZWNvbmRBcmcucHVzaENvbnRhaW5lcihcbiAgICAgICAgJ3Byb3BlcnRpZXMnLFxuICAgICAgICB0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcignc2NvcGUnKSwgYnVpbGRTY29wZShiYWJlbCwgbG9jYWxzKSlcbiAgICAgICk7XG4gICAgICAoXG4gICAgICAgIHNlY29uZEFyZy5nZXQoXG4gICAgICAgICAgYHByb3BlcnRpZXMuJHtzZWNvbmRBcmcubm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCAtIDF9YFxuICAgICAgICApIGFzIE5vZGVQYXRoPHQuT2JqZWN0UHJvcGVydHk+XG4gICAgICApLnNjb3BlLmNyYXdsKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFsb2NhbHMuaXNFbXB0eSgpKSB7XG4gICAgdGFyZ2V0LnB1c2hDb250YWluZXIoXG4gICAgICAnYXJndW1lbnRzJyxcbiAgICAgIHQub2JqZWN0RXhwcmVzc2lvbihbdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIoJ3Njb3BlJyksIGJ1aWxkU2NvcGUoYmFiZWwsIGxvY2FscykpXSlcbiAgICApO1xuICAgICh0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMScpIGFzIE5vZGVQYXRoPHQuT2JqZWN0RXhwcmVzc2lvbj4pLnNjb3BlLmNyYXdsKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZhbEFuZFNjb3BlKHRhcmdldDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4pIHtcbiAgbGV0IHNlY29uZEFyZyA9IHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4xJykgYXMgTm9kZVBhdGg8dC5PYmplY3RFeHByZXNzaW9uPiB8IHVuZGVmaW5lZDtcbiAgaWYgKHNlY29uZEFyZykge1xuICAgIGxldCBldmFsUHJvcCA9IHNlY29uZEFyZy5nZXQoJ3Byb3BlcnRpZXMnKS5maW5kKChwKSA9PiB7XG4gICAgICBsZXQga2V5ID0gcC5nZXQoJ2tleScpIGFzIE5vZGVQYXRoPHQuTm9kZT47XG4gICAgICByZXR1cm4ga2V5LmlzSWRlbnRpZmllcigpICYmIGtleS5ub2RlLm5hbWUgPT09ICdldmFsJztcbiAgICB9KTtcbiAgICBpZiAoZXZhbFByb3ApIHtcbiAgICAgIGV2YWxQcm9wLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGxldCBjb21wb25lbnRQcm9wID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ2NvbXBvbmVudCc7XG4gICAgfSk7XG4gICAgaWYgKGNvbXBvbmVudFByb3ApIHtcbiAgICAgIGNvbXBvbmVudFByb3AucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIEdpdmVuIGEgY2FsbCB0byB0ZW1wbGF0ZSgpLCBjb252ZXJ0IGl0cyBcInN0cmljdFwiIGFyZ3VtZW50IGludG9cbi8vIHByZWNvbXBpbGVUZW1wbGF0ZSdzIFwic3RyaWN0TW9kZVwiIGFyZ3VtZW50LiBUaGV5IGRpZmZlciBpbiBuYW1lIGFuZCBkZWZhdWx0XG4vLyB2YWx1ZS5cbmZ1bmN0aW9uIGNvbnZlcnRTdHJpY3RNb2RlKGJhYmVsOiB0eXBlb2YgQmFiZWwsIHRhcmdldDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4pIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgbGV0IHNlY29uZEFyZyA9IHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4xJykgYXMgTm9kZVBhdGg8dC5PYmplY3RFeHByZXNzaW9uPiB8IHVuZGVmaW5lZDtcbiAgaWYgKHNlY29uZEFyZykge1xuICAgIGxldCBzdHJpY3QgPSBzZWNvbmRBcmcuZ2V0KCdwcm9wZXJ0aWVzJykuZmluZCgocCkgPT4ge1xuICAgICAgbGV0IGtleSA9IHAuZ2V0KCdrZXknKSBhcyBOb2RlUGF0aDx0Lk5vZGU+O1xuICAgICAgcmV0dXJuIGtleS5pc0lkZW50aWZpZXIoKSAmJiBrZXkubm9kZS5uYW1lID09PSAnc3RyaWN0JztcbiAgICB9KSBhcyBOb2RlUGF0aDx0Lk9iamVjdFByb3BlcnR5PjtcbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICBzdHJpY3Quc2V0KCdrZXknLCB0LmlkZW50aWZpZXIoJ3N0cmljdE1vZGUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlY29uZEFyZy5wdXNoQ29udGFpbmVyKFxuICAgICAgICAncHJvcGVydGllcycsXG4gICAgICAgIHQub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKCdzdHJpY3RNb2RlJyksIHQuYm9vbGVhbkxpdGVyYWwodHJ1ZSkpXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQucHVzaENvbnRhaW5lcihcbiAgICAgICdhcmd1bWVudHMnLFxuICAgICAgdC5vYmplY3RFeHByZXNzaW9uKFt0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcignc3RyaWN0TW9kZScpLCB0LmJvb2xlYW5MaXRlcmFsKHRydWUpKV0pXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVBydW5lSW1wb3J0KFxuICB1dGlsOiBJbXBvcnRVdGlsLFxuICBpZGVudGlmaWVyOiBOb2RlUGF0aDx0LkV4cHJlc3Npb24gfCB0LlY4SW50cmluc2ljSWRlbnRpZmllcj5cbikge1xuICBpZiAoIWlkZW50aWZpZXIuaXNJZGVudGlmaWVyKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGJpbmRpbmcgPSBpZGVudGlmaWVyLnNjb3BlLmdldEJpbmRpbmcoaWRlbnRpZmllci5ub2RlLm5hbWUpO1xuXG4gIGlmICghYmluZGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBmb3VuZCA9IGJpbmRpbmcucmVmZXJlbmNlUGF0aHMuZmluZCgocGF0aCkgPT4gcGF0aC5ub2RlID09PSBpZGVudGlmaWVyLm5vZGUpO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYmluZGluZy5yZWZlcmVuY2VQYXRocy5zcGxpY2UoYmluZGluZy5yZWZlcmVuY2VQYXRocy5pbmRleE9mKGZvdW5kKSwgMSk7XG4gIGJpbmRpbmcucmVmZXJlbmNlcy0tO1xuXG4gIGlmIChiaW5kaW5nLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICBsZXQgc3BlY2lmaWVyID0gYmluZGluZy5wYXRoO1xuICAgIGlmIChzcGVjaWZpZXIuaXNJbXBvcnRTcGVjaWZpZXIoKSkge1xuICAgICAgbGV0IGRlY2xhcmF0aW9uID0gc3BlY2lmaWVyLnBhcmVudFBhdGggYXMgTm9kZVBhdGg8dC5JbXBvcnREZWNsYXJhdGlvbj47XG4gICAgICB1dGlsLnJlbW92ZUltcG9ydChkZWNsYXJhdGlvbi5ub2RlLnNvdXJjZS52YWx1ZSwgbmFtZShzcGVjaWZpZXIubm9kZS5pbXBvcnRlZCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVjb21waWxlVGVtcGxhdGUoaTogSW1wb3J0ZXIpIHtcbiAgcmV0dXJuIGkuaW1wb3J0KCdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nLCAncHJlY29tcGlsZVRlbXBsYXRlJyk7XG59XG5cbmZ1bmN0aW9uIG5hbWUobm9kZTogdC5TdHJpbmdMaXRlcmFsIHwgdC5JZGVudGlmaWVyKSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdTdHJpbmdMaXRlcmFsJykge1xuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFrZVBsdWdpbjxPcHRpb25zPigob3B0aW9ucykgPT4gb3B0aW9ucyk7XG4iXX0=