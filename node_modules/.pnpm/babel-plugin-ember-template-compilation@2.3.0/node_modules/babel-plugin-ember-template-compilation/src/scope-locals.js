"use strict";
/*
  This class exists because:
   - before template compilation starts, we need to pass a `locals` array to
     ember-template-compiler
   - the JSUtils API can mutate the scope during template compilation
   - those scope mutations need to update both the original `locals` array and
     our own name mapping, keeping them in sync.
*/
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ScopeLocals_instances, _ScopeLocals_mapping, _ScopeLocals_locals, _ScopeLocals_params, _ScopeLocals_isInJsScope;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScopeLocals = void 0;
const hbs_utils_1 = require("./hbs-utils");
const read_only_array_1 = require("./read-only-array");
class ScopeLocals {
    constructor(params) {
        _ScopeLocals_instances.add(this);
        _ScopeLocals_mapping.set(this, {});
        _ScopeLocals_locals.set(this, []);
        _ScopeLocals_params.set(this, void 0);
        __classPrivateFieldSet(this, _ScopeLocals_params, params, "f");
    }
    get locals() {
        return (0, read_only_array_1.readOnlyArray)(__classPrivateFieldGet(this, _ScopeLocals_locals, "f"), 'The only supported way to manipulate locals is via the jsutils API\nhttps://github.com/emberjs/babel-plugin-ember-template-compilation#jsutils-manipulating-javascript-from-within-ast-transforms');
    }
    has(key) {
        return key in __classPrivateFieldGet(this, _ScopeLocals_mapping, "f");
    }
    get(key) {
        return __classPrivateFieldGet(this, _ScopeLocals_mapping, "f")[key];
    }
    isEmpty() {
        return __classPrivateFieldGet(this, _ScopeLocals_locals, "f").length === 0;
    }
    entries() {
        return Object.entries(__classPrivateFieldGet(this, _ScopeLocals_mapping, "f"));
    }
    add(hbsName, jsName) {
        __classPrivateFieldGet(this, _ScopeLocals_mapping, "f")[hbsName] = jsName !== null && jsName !== void 0 ? jsName : hbsName;
        if (!__classPrivateFieldGet(this, _ScopeLocals_locals, "f").includes(hbsName)) {
            __classPrivateFieldGet(this, _ScopeLocals_locals, "f").push(hbsName);
        }
    }
    // this AST transform discovers all possible upvars in HBS that refer to valid
    // bindings in JS, and then depending on the mode adjusts our actual scope bag
    // contents.
    crawl() {
        return (_env) => {
            let seen;
            return {
                name: 'scope-locals-crawl',
                visitor: {
                    Template: {
                        enter: () => {
                            seen = new Set();
                        },
                        exit: (_node, _path) => {
                            if (__classPrivateFieldGet(this, _ScopeLocals_params, "f").mode === 'implicit') {
                                // all hbs upvars that have matching JS bindings go into the
                                // scope
                                for (let name of seen) {
                                    if (__classPrivateFieldGet(this, _ScopeLocals_instances, "m", _ScopeLocals_isInJsScope).call(this, name, __classPrivateFieldGet(this, _ScopeLocals_params, "f").jsPath)) {
                                        this.add(name);
                                    }
                                }
                            }
                            else {
                                // in explicit form, we might prune back the preexising scope in
                                // the case where another AST transform has eliminated the use
                                // of the original binding. But we don't add anything new. The
                                // only way for new bindings to be introduced into scope is for
                                // another AST transform to explicitly call the jsutils, which
                                // calls our `add`.
                                for (let name of Object.keys(__classPrivateFieldGet(this, _ScopeLocals_mapping, "f"))) {
                                    if (!seen.has(name)) {
                                        __classPrivateFieldGet(this, _ScopeLocals_locals, "f").splice(__classPrivateFieldGet(this, _ScopeLocals_locals, "f").indexOf(name), 1);
                                        delete __classPrivateFieldGet(this, _ScopeLocals_mapping, "f")[name];
                                    }
                                }
                            }
                        },
                    },
                    PathExpression: (node, path) => {
                        if (node.head.type !== 'VarHead') {
                            return;
                        }
                        const name = node.head.name;
                        if (!(0, hbs_utils_1.astNodeHasBinding)(path, name)) {
                            seen.add(name);
                        }
                    },
                    ElementNode: (node, path) => {
                        const name = node.tag.split('.')[0];
                        if (!(0, hbs_utils_1.astNodeHasBinding)(path, name)) {
                            seen.add(name);
                        }
                    },
                },
            };
        };
    }
}
exports.ScopeLocals = ScopeLocals;
_ScopeLocals_mapping = new WeakMap(), _ScopeLocals_locals = new WeakMap(), _ScopeLocals_params = new WeakMap(), _ScopeLocals_instances = new WeakSet(), _ScopeLocals_isInJsScope = function _ScopeLocals_isInJsScope(hbsName, jsPath) {
    var _a;
    let jsName = (_a = __classPrivateFieldGet(this, _ScopeLocals_mapping, "f")[hbsName]) !== null && _a !== void 0 ? _a : hbsName;
    return ['globalThis'].includes(jsName) || jsPath.scope.getBinding(jsName);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NvcGUtbG9jYWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2NvcGUtbG9jYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7OztFQU9FOzs7Ozs7Ozs7Ozs7Ozs7QUFJRiwyQ0FBZ0Q7QUFDaEQsdURBQWtEO0FBcUJsRCxNQUFhLFdBQVc7SUFDdEIsWUFBWSxNQUFjOztRQUkxQiwrQkFBbUMsRUFBRSxFQUFDO1FBQ3RDLDhCQUFvQixFQUFFLEVBQUM7UUFDdkIsc0NBQWdCO1FBTGQsdUJBQUEsSUFBSSx1QkFBVyxNQUFNLE1BQUEsQ0FBQztJQUN4QixDQUFDO0lBTUQsSUFBSSxNQUFNO1FBQ1IsT0FBTyxJQUFBLCtCQUFhLEVBQ2xCLHVCQUFBLElBQUksMkJBQVEsRUFDWixtTUFBbU0sQ0FDcE0sQ0FBQztJQUNKLENBQUM7SUFFRCxHQUFHLENBQUMsR0FBVztRQUNiLE9BQU8sR0FBRyxJQUFJLHVCQUFBLElBQUksNEJBQVMsQ0FBQztJQUM5QixDQUFDO0lBRUQsR0FBRyxDQUFDLEdBQVc7UUFDYixPQUFPLHVCQUFBLElBQUksNEJBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQsT0FBTztRQUNMLE9BQU8sdUJBQUEsSUFBSSwyQkFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVELE9BQU87UUFDTCxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsdUJBQUEsSUFBSSw0QkFBUyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVELEdBQUcsQ0FBQyxPQUFlLEVBQUUsTUFBZTtRQUNsQyx1QkFBQSxJQUFJLDRCQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsTUFBTSxhQUFOLE1BQU0sY0FBTixNQUFNLEdBQUksT0FBTyxDQUFDO1FBQzNDLElBQUksQ0FBQyx1QkFBQSxJQUFJLDJCQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDcEMsdUJBQUEsSUFBSSwyQkFB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LENBQUMsWUFBWSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzVFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBUaGlzIGNsYXNzIGV4aXN0cyBiZWNhdXNlOlxuICAgLSBiZWZvcmUgdGVtcGxhdGUgY29tcGlsYXRpb24gc3RhcnRzLCB3ZSBuZWVkIHRvIHBhc3MgYSBgbG9jYWxzYCBhcnJheSB0b1xuICAgICBlbWJlci10ZW1wbGF0ZS1jb21waWxlclxuICAgLSB0aGUgSlNVdGlscyBBUEkgY2FuIG11dGF0ZSB0aGUgc2NvcGUgZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG4gICAtIHRob3NlIHNjb3BlIG11dGF0aW9ucyBuZWVkIHRvIHVwZGF0ZSBib3RoIHRoZSBvcmlnaW5hbCBgbG9jYWxzYCBhcnJheSBhbmRcbiAgICAgb3VyIG93biBuYW1lIG1hcHBpbmcsIGtlZXBpbmcgdGhlbSBpbiBzeW5jLlxuKi9cblxuaW1wb3J0IHR5cGUgeyBOb2RlUGF0aCB9IGZyb20gJ0BiYWJlbC90cmF2ZXJzZSc7XG5pbXBvcnQgeyBBU1RQbHVnaW5FbnZpcm9ubWVudCwgTm9kZVZpc2l0b3IgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuaW1wb3J0IHsgYXN0Tm9kZUhhc0JpbmRpbmcgfSBmcm9tICcuL2hicy11dGlscyc7XG5pbXBvcnQgeyByZWFkT25seUFycmF5IH0gZnJvbSAnLi9yZWFkLW9ubHktYXJyYXknO1xuXG4vKlxuICAgIGBtb2RlYCByZWZlcnMgdG8gdGhlIGltcGxpY2l0IGFuZCBleHBsaWNpdCBmb3JtYXRzIGRlZmluZWQgaGVyZTpcblxuICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2VtYmVyanMvcmZjcy9ibG9iLzlmZDZjZWFjMjU1OWJlZTFjMzNhY2YwZDc4MzRlNjc1MTI1YTRmMTYvdGV4dC8wOTMxLXRlbXBsYXRlLWNvbXBpbGVyLWFwaS5tZCNleHBsaWNpdC1mb3JtXG4gICAgICBodHRwczovL2dpdGh1Yi5jb20vZW1iZXJqcy9yZmNzL2Jsb2IvOWZkNmNlYWMyNTU5YmVlMWMzM2FjZjBkNzgzNGU2NzUxMjVhNGYxNi90ZXh0LzA5MzEtdGVtcGxhdGUtY29tcGlsZXItYXBpLm1kI2ltcGxpY2l0LWZvcm1cblxuICAgIFRoaXMgY2xhc3MgbmVlZHMgdG8ga25vdyB0aGUgZGlmZmVyZW5jZSBiZWNhdXNlIGluIGltcGxpY2l0IGZvcm1hdCwgdXB2YXJzXG4gICAgaW4gaGJzIGFyZSBhdXRvbWFnaWNhbGx5IGNvbm5lY3RlZCB3aXRoIG91dGVyIEphdmFzY3JpcHQgYmluZGluZ3MsIGFuZCBpblxuICAgIGV4cGxpY2l0IGZvcm0gdGhleSBhcmUgbm90LlxuKi9cbnR5cGUgUGFyYW1zID1cbiAgfCB7XG4gICAgICBtb2RlOiAnZXhwbGljaXQnO1xuICAgIH1cbiAgfCB7XG4gICAgICBtb2RlOiAnaW1wbGljaXQnO1xuICAgICAganNQYXRoOiBOb2RlUGF0aDtcbiAgICB9O1xuXG5leHBvcnQgY2xhc3MgU2NvcGVMb2NhbHMge1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IFBhcmFtcykge1xuICAgIHRoaXMuI3BhcmFtcyA9IHBhcmFtcztcbiAgfVxuXG4gICNtYXBwaW5nOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICNsb2NhbHM6IHN0cmluZ1tdID0gW107XG4gICNwYXJhbXM6IFBhcmFtcztcblxuICBnZXQgbG9jYWxzKCkge1xuICAgIHJldHVybiByZWFkT25seUFycmF5KFxuICAgICAgdGhpcy4jbG9jYWxzLFxuICAgICAgJ1RoZSBvbmx5IHN1cHBvcnRlZCB3YXkgdG8gbWFuaXB1bGF0ZSBsb2NhbHMgaXMgdmlhIHRoZSBqc3V0aWxzIEFQSVxcbmh0dHBzOi8vZ2l0aHViLmNvbS9lbWJlcmpzL2JhYmVsLXBsdWdpbi1lbWJlci10ZW1wbGF0ZS1jb21waWxhdGlvbiNqc3V0aWxzLW1hbmlwdWxhdGluZy1qYXZhc2NyaXB0LWZyb20td2l0aGluLWFzdC10cmFuc2Zvcm1zJ1xuICAgICk7XG4gIH1cblxuICBoYXMoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMuI21hcHBpbmc7XG4gIH1cblxuICBnZXQoa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLiNtYXBwaW5nW2tleV07XG4gIH1cblxuICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLiNsb2NhbHMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy4jbWFwcGluZyk7XG4gIH1cblxuICBhZGQoaGJzTmFtZTogc3RyaW5nLCBqc05hbWU/OiBzdHJpbmcpIHtcbiAgICB0aGlzLiNtYXBwaW5nW2hic05hbWVdID0ganNOYW1lID8/IGhic05hbWU7XG4gICAgaWYgKCF0aGlzLiNsb2NhbHMuaW5jbHVkZXMoaGJzTmFtZSkpIHtcbiAgICAgIHRoaXMuI2xvY2Fscy5wdXNoKGhic05hbWUpO1xuICAgIH1cbiAgfVxuXG4gICNpc0luSnNTY29wZShoYnNOYW1lOiBzdHJpbmcsIGpzUGF0aDogTm9kZVBhdGgpIHtcbiAgICBsZXQganNOYW1lID0gdGhpcy4jbWFwcGluZ1toYnNOYW1lXSA/PyBoYnNOYW1lO1xuICAgIHJldHVybiBbJ2dsb2JhbFRoaXMnXS5pbmNsdWRlcyhqc05hbWUpIHx8IGpzUGF0aC5zY29wZS5nZXRCaW5kaW5nKGpzTmFtZSk7XG4gIH1cblxuICAvLyB0aGlzIEFTVCB0cmFuc2Zvcm0gZGlzY292ZXJzIGFsbCBwb3NzaWJsZSB1cHZhcnMgaW4gSEJTIHRoYXQgcmVmZXIgdG8gdmFsaWRcbiAgLy8gYmluZGluZ3MgaW4gSlMsIGFuZCB0aGVuIGRlcGVuZGluZyBvbiB0aGUgbW9kZSBhZGp1c3RzIG91ciBhY3R1YWwgc2NvcGUgYmFnXG4gIC8vIGNvbnRlbnRzLlxuICBjcmF3bCgpIHtcbiAgICByZXR1cm4gKF9lbnY6IEFTVFBsdWdpbkVudmlyb25tZW50KTogeyBuYW1lOiBzdHJpbmc7IHZpc2l0b3I6IE5vZGVWaXNpdG9yIH0gPT4ge1xuICAgICAgbGV0IHNlZW46IFNldDxzdHJpbmc+O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3Njb3BlLWxvY2Fscy1jcmF3bCcsXG4gICAgICAgIHZpc2l0b3I6IHtcbiAgICAgICAgICBUZW1wbGF0ZToge1xuICAgICAgICAgICAgZW50ZXI6ICgpID0+IHtcbiAgICAgICAgICAgICAgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleGl0OiAoX25vZGUsIF9wYXRoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLiNwYXJhbXMubW9kZSA9PT0gJ2ltcGxpY2l0Jykge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBoYnMgdXB2YXJzIHRoYXQgaGF2ZSBtYXRjaGluZyBKUyBiaW5kaW5ncyBnbyBpbnRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNjb3BlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBzZWVuKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaXNJbkpzU2NvcGUobmFtZSwgdGhpcy4jcGFyYW1zLmpzUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluIGV4cGxpY2l0IGZvcm0sIHdlIG1pZ2h0IHBydW5lIGJhY2sgdGhlIHByZWV4aXNpbmcgc2NvcGUgaW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgY2FzZSB3aGVyZSBhbm90aGVyIEFTVCB0cmFuc2Zvcm0gaGFzIGVsaW1pbmF0ZWQgdGhlIHVzZVxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBvcmlnaW5hbCBiaW5kaW5nLiBCdXQgd2UgZG9uJ3QgYWRkIGFueXRoaW5nIG5ldy4gVGhlXG4gICAgICAgICAgICAgICAgLy8gb25seSB3YXkgZm9yIG5ldyBiaW5kaW5ncyB0byBiZSBpbnRyb2R1Y2VkIGludG8gc2NvcGUgaXMgZm9yXG4gICAgICAgICAgICAgICAgLy8gYW5vdGhlciBBU1QgdHJhbnNmb3JtIHRvIGV4cGxpY2l0bHkgY2FsbCB0aGUganN1dGlscywgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyBjYWxscyBvdXIgYGFkZGAuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLiNtYXBwaW5nKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNsb2NhbHMuc3BsaWNlKHRoaXMuI2xvY2Fscy5pbmRleE9mKG5hbWUpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuI21hcHBpbmdbbmFtZV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgUGF0aEV4cHJlc3Npb246IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5oZWFkLnR5cGUgIT09ICdWYXJIZWFkJykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbm9kZS5oZWFkLm5hbWU7XG4gICAgICAgICAgICBpZiAoIWFzdE5vZGVIYXNCaW5kaW5nKHBhdGgsIG5hbWUpKSB7XG4gICAgICAgICAgICAgIHNlZW4uYWRkKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgRWxlbWVudE5vZGU6IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbm9kZS50YWcuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgICAgIGlmICghYXN0Tm9kZUhhc0JpbmRpbmcocGF0aCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgc2Vlbi5hZGQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuIl19